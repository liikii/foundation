https://www.seas.harvard.edu/courses/cs152/2021sp/resources.html
The Curry-Howard Isomorphism
Resources
Text books
A number of excellent books and on-line resources overlap with the course's content and can provide alternate explanations despite differences in notation and approach. Let the instructor know if you have trouble finding the intersection between these resources and the course content.

"Types and Programming Languages" by Benjamin C. Pierce, MIT Press, 2002.
Available on reserve at the library.
"Software Foundations" by Benjamin C. Pierce et al., Volume 1: Logical Foundations and Volume 2: Programming Language Foundations.
Available as literate Coq files.
Also available as literate Agda files thanks to Philip Wadler, Wen Kokke and Jeremy Siek.
"Practical Foundations for Programming Languages" by Robert Harper, Cambridge University Press, 2013.
Draft available on Harper's website.
"Concepts in Programming Languages" by John C. Mitchell, Cambridge University Press, 2003.
Available online through Harvard University Libraries eContent Collection.
"The Formal Semantics of Programming Languages" by Glynn Winskel, MIT Press, 1993.
Available on reserve at the library.
"Programming Languages: Application and Interpretation" by Shriram Krishnamurthi.
There are two editions, both available on the author's website: http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/.
OCaml resources
Installation: https://ocaml.org/docs/install.html
Tools: https://github.com/realworldocaml/book/wiki/Installation-Instructions
This link gives instructions for installing things like Tuareg (a useful emacs mode) and Merlin (advanced IDE features).

Installing Tuareg is pretty simple and will make your OCaml coding experience a lot nicer (though it's of course not necessary). Merlin is probably overkill unless you know what you're doing.

Learning:
Standard library documentation: http://caml.inria.fr/pub/docs/manual-ocaml/libref/index.html
The following documentation may be particularly useful as you work on your assignments.
Sets: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.Make.html
Maps: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.Make.html
Everything you need to know and more: http://caml.inria.fr/pub/docs/manual-ocaml/index.html
Code examples: http://ocaml.org/learn/tutorials/99problems.html
See also the CS51 Resources web page for OCaml books, references, and tutorials.

Coq resources
Download Coq.
Coq includes an IDE, CoqIDE. Alternatively, with Emacs, you can use Proof General.
Coq documentation.
Dafny resources
Dafny on Github.
Dafny on rise4fun.
Dafny in Visual Studio Code.
Haskell resources
Download The Haskell Platform.
List of Haskell tutorials. If you want to get more meta, see How to Learn Haskell.
haskell.org contains lots of reference information, language specification, etc.



Gödel's incompleteness theorems are two theorems of mathematical logic that demonstrate the inherent limitations of every formal axiomatic system capable of modelling basic arithmetic. These results, published by Kurt Gödel in 1931, are important both in mathematical logic and in the philosophy of mathematics. The theorems are widely, but not universally, interpreted as showing that Hilbert's program to find a complete and consistent set of axioms for all mathematics is impossible.



<select name="textbook">
SELECT textbook </option>

Aho, Sethi, Ullman - Compilers</option>
Brookshear - Computer Science - An Overview </option>
Brookshear - Theory of Computation </option>
Cohen - Intro to Computer Theory </option>
Davis - Computability, Complexity, and Languages </option>
Du and Ko - Problem Solving in Automata, Languages and Complexity </option>
Floyd and Beigel - The Language of Machines</option>
Gersting - Mathematical Structures for Computer Science</option>
Goddard - Introducing the Theory of Computation </option>
Homer - Computability and Complexity Theory </option>
Johnsonbaugh - Discrete Mathematics </option>
Kelley - Automata and Formal Languages </option>
Kinber and Smith - Theory of Computing</option>
Kozen - Automata and Computability </option>
Lewis and Papadimitriou - Elements of the Theory of Computation </option>
Linz - Formal Languages and Automata</option>
Martin - Introduction to Languages and the Theory of Computation</option>
Motwani, Ullman and Hopcroft - Intro to Automata Theory, Languages
and Computation </option>
Sipser - Introduction to the Theory of Computation
Sudkamp - Languages and Machines
Taylor - Models of Computation and Formal Languages
OTHER 



可计算的route
david hilbert 提出   数学系统公理化完整性
Kurt Gödel 证明无法完整性。 
alonzo church 和 alan turing 也证明形式系统不完整。 


数学的不确定性

构造一个形式系统， 让形式系统出现自证的悖论
同构的威力

galois theory


分点突破


galois theory的一点点思考：
根的对称性
群的对称性
分裂域 与  galois group 的对称性

大于5次  一点关系没有办法满足。 




lagrange root permutation
the roots of early group theory in the works of lagrange. 



The symmetric polynomials
Albert Girard (1590-1633), a flemish mathematician, published in 1629, in Amsterdam, a book called Invention nouvelle en l'algèbre, in which clear relations between roots and coefficients of polynomials were stated for the first time.



Edward Waring (1734-1793), an English mathematician, searched for the correlations between the degrees of the resolvent polynomials of a polynomial


The work of Lagrange
Joseph Louis Lagrange (1736-1813), a French mathematician, proved that a polynomial equation can be solved by radicals if a particularly related equation called the Lagrange resultant has degree less than the degree of the original equation. The proof involved a concept that later was to become fundamental to the theory of polynomial equations: that of the permutation of the roots. The Lagrange resultant is a polynomial constructed by means of a rational function of all possible permutations of the roots. An important characteristic of the theorem is that it is an existence theorem, as opposed to the previous methods that had all been concerned with the construction of a solving formula. Using this result, Ruffini produced in 1799 an erroneous proof that a polynomial equation od degree greater than 4 was not soluble by radicals. Abel independently found in 1824 a correct proof of the same theorem; thus the question of solving polynomial equation was in part settled. Still there are polynomials of degree greater than 4 that are clearly soluble, like tex2html_wrap_inline304. What remained to be done was to find a method to determine exactly which polynomial is soluble.


The work of Vandermonde and Gauss
Vandermonde proposed in 1770 that the key to solving a general polynomial equation
displaymath306
was represented by the roots of the equation tex2html_wrap_inline308. Gauss has the undoubted credit for having laid the first stone in the path that Galois successively followed. He showed that the roots of the polynomial equation tex2html_wrap_inline310 where p is prime are rational functions of the roots of a sequence of equations tex2html_wrap_inline314 where the coefficients of tex2html_wrap_inline316 are rational expressions of the roots of tex2html_wrap_inline318 and the degrees of the polynomials in the sequence are the all the prime numbers in the factorization of p-1.


It is not surprising that Galois was not understood even by the greatest mathematicians of the time. His papers make such a large number of unproved (though true) assumptions, that at first they really are incomprehensible. Modern Galois theory can be viewed from two possible angles, which are however closely linked: group theory and field theory. Following the group-theoretic approach, to each polynomial there corresponds a group of permutations of the roots; if the group contains a series of certain particular nested subgroups such that the intersection of the series is the identity element, this means that the identity is the only permutation of the roots that leave all the known rational relations between the roots valid, and hence it is possible to determine them. If the intersection contains other permutations apart from the identity, it means that all the known relations cannot determine the roots because even if we permute them with the permutations in the intersection the relations still hold. Taking the field-theoretic approach, for any polynomial having roots tex2html_wrap_inline322 and coefficients in the field F there exists a field F' such that the polynomial is reducible into linear factors in F'. Obviously any field tex2html_wrap_inline330 is such that the polynomial splits into linear factors. Any such field G is called a splitting field for f(x). It is clear that for any polynomial f(x) over F with roots tex2html_wrap_inline322 the field tex2html_wrap_inline342 is a splitting field for f. Very simply put, if F' is expressible by adjoining a finite number of radicals of the form tex2html_wrap_inline348 to the base field F, then it is possible to express the roots tex2html_wrap_inline322 in terms of the radical operations tex2html_wrap_inline354 and hence there is a radical formula to find the roots in terms of the coefficients. Thus Galois found necessary and sufficient conditions for the roots to be expressed as rational functions of the coefficients, settling the problem definitively.





-----some book---
Inside the Machine: An Illustrated Introduction to Microprocessors and Computer Architecture
Structure and Interpretation of Computer Programs
Design Patterns: Elements of Reusable Object-Oriented Software
Code: The Hidden Language of Computer Hardware and Software
Cracking the Coding Interview: 189 Programming Questions and Solutions
Code Complete: A Practical Handbook of Software Construction
Programming Pearls
The Pragmatic Programmer: Your Journey to Mastery
Code Simplicity: The Fundamentals of Software
Algorithms to Live By: The Computer Science of Human Decisions
Clean Code: A Handbook of Agile Software Craftsmanship
Think Like a Programmer: An Introduction to Creative Problem Solving
Introduction to Algorithms
Peopleware: Productive Projects and Teams
Soft Skills: The software developer’s life manual&nbsp;
Rapid Development: Taming Wild Software Schedules
Coders at Work: Reflections on the Craft of Programming
Don’t Make Me Think, Revisited: A Common Sense Approach to Web Usability
The Passionate Programmer: Creating a Remarkable Career in Software Development
Working Effectively with Legacy Code
The Self-Taught Programmer: The Definitive Guide to Programming Professionally
The Mythical Man-Month: Essays on Software Engineering
Refactoring: Improving the Design of Existing Code
HTML and CSS: Design and Build Websites
Learning Web Design: A Beginner’s Guide to HTML, CSS, JavaScript, and Web Graphics
Eloquent JavaScript: A Modern Introduction to Programming
You Don’t Know JS Yet: Get Started
Effective Java
Head First Java
Java Concurrency in Practice
Modern PHP
Head First PHP &amp; MySQL: A Brain-Friendly Guide
Eloquent Ruby
The Well-Grounded Rubyist
Python Crash Course: A Hands-On, Project-Based Introduction to Programming
Head First Python: A Brain-Friendly Guide
Learn Python 3 the Hard Way: A Very Simple Introduction to the Terrifyingly Beautiful World of Computers and Code
C# in Depth
C# 7.0 in a Nutshell: The Definitive Reference
C Programming Language
Practical C Programming: Why Does 2+2 = 5986?
Objective-C Programming: The Big Nerd Ranch Guide
Effective Objective-C 2.0: 52 Specific Ways to Improve Your IOS and OS X Programs
C++ Primer
Programming: Principles and Practice Using C++
Learning R: A Step-by-Step Function Guide to Data Analysis
R Cookbook: Proven Recipes for Data Analysis, Statistics, and Graphics
The Art of R Programming: A Tour of Statistical Software Design
SQL in 10 Minutes, Sams Teach Yourself
SQL Queries for Mere Mortals: A Hands-On Guide to Data Manipulation in SQL
Android Application Development All-in-One For Dummies
Head First Android Development: A Brain-Friendly Guide
iOS Programming: The Big Nerd Ranch Guide
Swift Programming: The Big Nerd Ranch Guide


--------


被识别叫作语言


A language is called a regular language if some finite automaton recognizes it.


regular operations union, concatenation, and star


nondeterministic finite automaton

EQUIVALENCE OF NFAS AND DFAS
1. 因为NFA会出现一个输入产生两个， 三个， 或多个状态的现象。 
2. 对状态做对自身的笛卡尔积，直到包含了所有状态，  然后重新绘制。 



 language is regular if and only if some nondeterministic finite automaton recognizes it


theorem 1:
 the class of regular languages is closed under the union operation.
构造一个NFA， 空指向两个子NFA。 证毕。

theorem 2:
The class of regular languages is closed under the concatenation operation.
同上， 构造NFA。 一个NFA 空连接另一个  NFA。


the class of regular languages is closed under the star operation.

在accept 状态用空连接 start 状态。 


A language is regular if and only if some regular expression describes it.


NONREGULAR LANGUAGES
找到违反他特征的例子。 

正则的特性
THE PUMPING LEMMA FOR REGULAR LANGUAGES
大于等于三的 string 中间存在可重复。 


---------

 context-free grammars::: recursive structure


pushdown automata, a class of machines recognizing the context-free languages

parse tree.


Any language that can be generated by some context-free grammar is called a context-free language(CFL).



fmcoirst, many CFLs are the union of simpler CFLs. If you must construct a CFG for
a CFL that you can break into simpler pieces, do so and then construct individual
grammars for each piece. These individual grammars can be easily merged into
a grammar for the original language by combining their rules and then adding
the new rule S → S1 | S2 | ··· | Sk, where the variables Si are the start variables
for the individual grammars. Solving several simpler problems is often easier
than solving one complicated problem.


computational model called pushdown automata.

finite automata 
为什么加stack, 可能就是为了方便识别递归。 
 context-free grammars and pushdown automata are
equivalent in power. Both are capable of describing the class of context-free languages. We show how to convert any context-free grammar into a pushdown automaton that recognizes the same language and vice versa. 


cfg to pda
stack 实现识别递归
: 递归的特征

(
 Theorem: If G is a CFG for a language L, 
then there exists a PDA for L as well.
● Idea: Build a PDA that simulates 
expanding out the CFG from the start 
symbol to some particular string.
● Stack holds the part of the string we 
haven't matched yet.)

THE PUMPING LEMMA FOR CONTEXT-FREE LANGUAGES
分成5部分。 
. It states that every context-free language has a special value called the pumping length such that all longer strings in the language can be “pumped.” This time the meaning of pumped is a bit more complex. It means that the string can be divided into five parts so that the second and the fourth parts may be repeated together any number of times and the resulting string still remains in the language.

找一个不是递归关系的。 

a(↑n)b(↑n)c(↑n)   他就不在



The languages that are recognizable by deterministic pushdown automata (DPDAs) are called deterministic context-free languages (DCFLs). 
This subclass of the context-free languages is relevant to practical applications, such as the design of parsers in compilers for programming languages, because the parsing problem is generally easier for DCFLs than for CFLs. This section gives a short overview of this important and beautiful subject.


 In a PDA, if there are multiple 
nondeterministic choices, you cannot
treat the machine as being in multiple 
states at once.
● Each state might have its own stack 
associated with it.
● Instead, there are multiple parallel 
copies of the machine running at once, 
each of which has its own stack



图灵机 与 lambda 演算的对等关系。 
图灵机 类似模拟 递归。 
turing machine lambda calculus equivalence

机算机核心问题
David Hilbert’s Entscheidungsproblem


The class of DCFLs is closed under complementation.
PROOF IDEA Swapping the accept and non-accept states of a DFA yields a new DFA that recognizes the complementary language, thereby proving that the class of regular languages is closed under complementation. 


加endmarked string也可被识别。 
A is a DCFL if and only if A⊣ is a DCFL.

DCFG
A deterministic context-free grammar is a context-free grammar such that every valid string has a forced handle.


单带 多带 TM。 
单带增加空间复杂度。 

o construct DFA DK, we’ll construct an equivalent NFA K and convert K to
DK1 via the subset construction introduced in Theorem 1.39.


对等关系  映射怎么找。 同构
every DCFG has an equivalent DPDA.

In the 1960s, theoretical research in computer science on regular expressions and finite automata led to the discovery that context-free grammars are equivalent to nondeterministic pushdown automata.[1][2][3] These grammars were thought to capture the syntax of computer programming languages. The first computer programming languages were under development at the time (see History of programming languages) and writing compilers was difficult. But using context-free grammars to help automate the parsing part of the compiler simplified the task. 



an LR(k) grammar is a context-free grammar such that the handle of every valid string is forced by lookahead k.



图灵机识别  011000#011000
Turing machine M1 computing on input 011000#011000

图灵机定义
 δ : Q × Γ−→Q × Γ × {L, R} is the transition function,

 Σ ⊆ Γ,


 表示法

  a Turing machine computes, changes occur in the current state, the current tape contents, and the current head location. A setting of these three items is called a configuration of the Turing machine. Configurations often are represented in a special way. For a state q and two strings u and v over the tape alphabet Γ, we write uqv for the configuration where the current state is q, the current tape contents is uv, and the current head location is the first symbol of v. The tape contains only blanks following the last symbol of v. For example,
1011q701111 represents the configuration when the tape is 101101111, the current state is q7, and the head is currently on the second 0. Figure 3.4 depicts a Turing machine with that configuration.


call a language Turing-recognizable if some Turing machine
recognizes it.1


call a language Turing-decidable or simply decidable if some
Turing machine decides it



every multitape Turing machine has an equivalent single-tape Turing machine



计算机发展史
John Mauchly
Oral history interview with J. Presper Eckert at Charles Babbage Institute, University of Minnesota, Minneapolis. Eckert, a co-inventor of the ENIAC, discusses its development at the University of Pennsylvania and the interaction of the personnel at the Moore School.
John W. Mauchly and the Development of the ENIAC Computer - by Asaf Goldschmidt and Atsushi Akera, An Exhibition in the Department of Special Collections Van Pelt Library, University of Pennsylvania
Mauchly: The Computer and the Skateboard. The only work to contain archival footage of John Mauchly speaking about the development of the ENIAC.
O'Connor, John J.; Robertson, Edmund F., "John Mauchly", MacTutor History of Mathematics archive, University of St Andrews.


, we prove one of the most philosophically important theorems of the theory of computation: There is a specific problem that is algorithmically unsolvable. Computers appear to be so powerful that you may believe that all problems will eventually yield to them. 


方法树， 在宽度上一个接收就接收。 都是拒绝的时候拒绝。 

TM：
识别器， 判定器， 转换器， 产生器， 枚举器。 


可识别等价可枚举。 
A language is Turing-recognizable if and only if some enumerator enumerates it. 


形式系统要么是不完备(complete)  要么不相容的（closure） 
不完备，


举一个复杂点的例子，也就是这一节最开头的那个表达式：

(5 - 3) * (4 + (2 * 3 - 5) * 6)
它可以被转化为一串语句：

{
    a = 2 * 3
    b = a - 5
    c = b * 6
    d = 4 + c
    e = 5 - 3
    e * d
}

王垠思想：
总有人提出一套套的所谓“方法论”或者“原则”，比如 Extreme Programming，Design Patterns，Agile，Pair Programming，Test Driven Development（TDD），DRY principle…… 他们把这些所谓方法论兜售给各个软件公司，鼓吹它们的各种好处，说使用这些方法，就可以用一些平庸的“软件工程师”，制造出高质量低成本的软件。这就跟减肥药的广告一样：不用运动，不用节食，一个星期瘦 20 斤。

你开头还不以为然，觉得这些肤浅的说法能造成什么影响。结果久而久之，这些所谓“方法论”和“原则”成为了整个行业的教条，造成了文化大革命一样的风气。违反这些教条的人，必然被当成菜鸟一样鄙视，当成小学生一样教育，当成反革命一样批斗。就算你技术比这些教条的提出者高不知道多少倍，也无济于事，因为他们已经靠着一张嘴占据了自己的地位。



可世界上就是有这样划算的行当，虽然写不出好的代码，对计算的理解非常肤浅，却可以通过嘴里说说，得到评价别人“代码质量”的权力，占据软件公司的管理层位置。久而久之，别人还以为他们是什么泰斗。你仔细看过提出 Design Pattern 的“四人帮”（GoF），做出过什么有实质价值的东西吗？提出“DRY Principle”的作者，做出过什么吗？再看看 Agile，Pair Programming，TDD 的提出者？他们其实不懂很多编程，写出文章和书来也是极其肤浅。

所谓“软件工程”，并不像土木工程，机械工程，电机工程，是建立在实际的，科学的基础上的。跟这些“硬工程”不一样，软件弄得不好不会出人命，也不会像芯片公司那样，出一个 bug 立即导致几十上百亿的损失。




想起这些借口我就想起一个笑话：两夫妻发现床上有跳蚤，身上被咬了好多包。去买了号称“杀伤率 100 %”的跳蚤药，撒了好多在床上。第二天早上起来，发现仍然被咬了好多新的包。妻子责怪丈夫，说他没看说明书就乱撒。结果丈夫打开说明书一看，内容如下：

本跳蚤药使用方法：

抓住跳蚤
掰开跳蚤的嘴
把药塞进跳蚤嘴里
合上跳蚤的嘴
我发现很多软件工程的所谓方法论失败之后的借口，跟这跳蚤药的说明书很像。





课程大纲
根据第二期课程的经验，我想对课程的内容做一个比以前详细的说明。之前一直对课程内容没有很多说明，一方面为的是留下自由发挥的空间，一方面是为了让学生有一定的神秘感，引发好奇心。但这么简单的说明似乎会让不知情的人误以为“已经学过这些东西”，有时候会发现一些人看了说明之后，自以为我教的内容他都会了。我只为他们感到可惜。

下面简要说一下课程的内容：

教学语言。课程目前使用 JavaScript 作为教学语言，但并不是教 JavaScript 语言本身，不会使用 JavaScript 特有的任何功能。课程教的思想不依赖于 JavaScript 的任何特性，它可以应用于任何语言，课程可以在任何时候换成任何语言。学生从零开始，学会的是计算机科学最核心的思想，从无到有创造出各种重要的概念，直到最后实现出自己的编程语言和类型系统。

课程强度。课程的设计是一个逐渐加大难度，比较辛苦，却很安全的山路，它通往很高的山峰。要参加课程，请做好付出努力的准备。在两个月的时间里，你每天需要至少一个小时来做练习，有的练习需要好几个小时才能做对。跟其他的计算机教学不同，学生不会因为缺少基础而放弃，不会误入歧途，也不会掉进陷阱出不来。学生需要付出很多的时间和努力，但没有努力是白费的。

曾经有一两个学生因为低估了学习的强度，同时又有其他重要任务，结果发现忙不过来，所以请合理的安排，不要在有其他重要任务的同时参加学习。

第一课：函数。跟一般课程不同，我不从所谓“Hello World”程序开始，也不会叫学生做一些好像有趣而其实无聊的小游戏。一开头我就讲最核心的内容：函数。关于函数只有很少几个知识点，但它们却是一切的核心。只知道很少的知识点的时候，对它们进行反复的练习，让头脑能够自如地对它们进行思考和变换，这是教学的要点。我为每个知识点设计了恰当的练习。

第一课的练习每个都很小，只需要一两行代码，却蕴含了深刻的原理。练习逐渐加大难度，直至超过博士课程的水平。我把术语都改头换面，要求学生不上网搜索相关内容，为的是他们的思维不受任何已有信息的干扰，独立做出这些练习。练习自成系统，一环扣一环。后面的练习需要从前面的练习获得的灵感，却不需要其它基础。有趣的是，经过正确的引导，好些学生把最难的练习都做出来了，完全零基础的学生也能做出绝大部分，这是我在世界名校的学生里都没有看到过的。具体的内容因为不剧透的原因，我就不继续说了。

第二课：递归。递归可以说是计算机科学（或数学）最重要的概念。我从最简单的递归函数开始，引导理解递归的本质，掌握对递归进行系统化思考的思路。递归是一个很多人自以为理解了的概念，而其实很多人都被错误的教学方式误导了。很多人提到递归，只能想起“汉诺塔”或者“八皇后”问题，却不能拿来解决实际问题。很多编程书籍片面强调递归的“缺点”，教学生如何“消除递归”，却看不到问题的真正所在——某些语言（比如 C 语言）早期的函数调用实现是错误而效率低下的，以至于学生被教导要避免递归。由于对于递归从来没有掌握清晰的思路，在将来的工作中一旦遇到复杂点的递归函数就觉得深不可测。

第三课：链表。从零开始，学生不依赖于任何语言的特性，实现最基本的数据结构。第一个数据结构就是链表，学生会在练习中实现许多操作链表的函数。这些函数经过了精心挑选安排，很多是函数式编程语言的基本函数，但通过独立把它们写出来，学生掌握的是递归的系统化思路。这使得他们能自如地对这类数据结构进行思考，解决新的递归问题。

与一般的数据结构课程不同，这个课程实现的大部分都是「函数式数据结构」，它们具有一些特别的，有用的性质。因为它们逻辑结构清晰，比起普通数据结构书籍会更容易理解。与 Haskell 社区的教学方式不同，我不会宗教式的强调纯函数的优点，而是客观地让学生领会到其中的优点，并且发现它们的弱点。学会了这些结构，在将来也容易推广到非函数式的结构，把两种看似不同的风格有机地结合在一起。

第四课：树结构。从链表逐渐推广出更复杂的数据结构——树。在后来的内容中，会常常用到这种结构。树可能是计算机科学中最常用，最重要的数据结构了，所以理解树的各种操作是很重要的。我们的树也都是纯函数式的。

第五课：计算器。在熟悉了树的基本操作之后，实现一个比较高级的计算器，它可以计算任意嵌套的算术表达式。算术表达式是一种“语法树”，从这个练习学生会理解“表达式是一棵树”这样的原理。

第六课：查找结构。理解如何实现 key-value 查找结构，并且亲手实现两种重要的查找数据结构。我们的查找结构也都是函数式数据结构。这些结构会在后来的解释器里派上大的用场，对它们的理解会巩固加深。

第七课：解释器。利用之前打好的基础，亲手实现计算机科学中最重要，也是通常认为最难理解的概念——解释器。解释器是理解各种计算机科学概念的关键，比如编程语言，操作系统，数据库，网络协议，Web 框架。计算机最核心的部件 CPU 其实就是一个解释器，所以解释器的认识能帮助你理解「计算机体系构架」，也就是计算机的“硬件”。你会发现这种硬件其实和软件差别不是很大。你可以认为解释器就是「计算」本身，所以它非常值得研究。对解释器的深入理解，也能帮助理解很多其它学科，比如自然语言，逻辑学。

第八课：类型系统。在解释器的基础上，学生会理解并实现一个相当高级的类型系统（type system）和类型检查器（typechecker）。这相当于实现一个类似 Java 的静态类型语言，但比 Java 在某些方面还要高级和灵活。我们的类型系统包含了对于类型最关键的要素，而不只是照本宣科地讲解某一种类型系统。当你对现有的语言里的类型系统不满意的时候，这些思路可以帮助你设计出自己的类型系统。学生会用动手的方式去理解静态类型系统的原理，其中的规则，却不含有任何公式。

类型系统的规则和实现，一般只会在博士级别的研究中才会出现，可以写成一本厚书（比如 TAPL 那样的），其中有各种神秘的逻辑公式。而我的学生从零开始，一节课就可以掌握这门技术的关键部分，实现出正确的类型系统，并且推导出正确的公式。有些类型规则是如此的微妙，以至于微软这么大的公司在 21 世纪做一个新的语言（TypeScript)，仍然会在初期犯下类型专家们早已熟知的基本错误。上过这个课程的很多同学，可以说对这些基础原理的理解已经超过了 TypeScript 的设计者，但由于接受的方式如此自然，他们有一些人还没有意识到自己的强大。

关于面向对象。虽然课程不会专门讲“面向对象”的思想，但面向对象思想的本质（去掉糟粕）会从一开头就融入到练习里。上过课的同学到后来发现，虽然我从来没直接教过面向对象，而其实他们已经理解了面向对象的本质是什么。在将来的实践中，他们可以用这个思路去看破面向对象思想的本质，并且合理地应用它。

奖励练习。途中我会通过“奖励练习”的方式补充其它内容。比如第二期的课程途中，我临时设计了一个 parser 的练习，做完了其它练习的同学通过这个练习，理解了 parser 的原理，写出了一个简单但逻辑严密的 parser。奖励练习之所以叫“奖励”，因为并不是所有学生都能得到这个练习，只有那些付出了努力，在其他练习中做到融会贯通，学有余力的学生才会给这个练习。这样会鼓励学生更加努力地学习。

如果理解了以上内容蕴含了什么，你可能就不会再问“这些我都学过了，我可不可以参加高级班”了，因为极少有人真的理解了以上内容。就算世界上最高级职位的一些程序员，大学里的教授，对于这些也有很多含糊不清的地方。我自己也通过讲授这些内容得到了启发。

一个朋友看了我的课程内容说，这不叫“基础班”，只能叫“大师班”。他不相信零基础的学生能跟上，但事实却是可行的。为什么不能即是“基础班”又是“大师班”呢？有句话说得好，大师只不过是把基础的东西理解得很透彻的人而已。我希望这个基础班能帮助人们获得本质的原理，帮助他们看透很多其它内容。所以上了“基础班”，可能在很长时间之内都不需要“高级班”了，因为他们已经获得了很强的自学能力，能够自己去探索未知的世界，攀登更高的山峰。



洪水算法
从源头一步一步向相邻点蔓延


-------------------------------------

通用图灵机可识别， 就是做同构。 
北京大学_刘田

可判定即可停机， 不会出现死循环是可计算

算法主要是学习那些东西是不可被计算的。 
可计算理论都是研究的不可计算的问题。 



正则（fa）的可计算问题:
	图灵机 可判定  正则。 
	nfa自动机是可计算的。 是可判定的。 在图灵模型上。 
	E(dfa)不接受任何串的dfa是可判定的。 
	把他转化成图的问题。 


	判定两个有穷自动机是否相等。 是可判定的。
	正则语言对称差运算是封闭的。 

上下文无关语言的可计算问题。 
	cfg的派生问题。是否可派生一个字串w， 证明方法， 变成Chomsky 范式， 因为n长度的Chomsky 范式是2n-1步，遍历所有2n-1的派生。 
	cfg 的空性问题。检查初始变原是否能产生一个终结符。 反向推导， 看终结符是否可以到原始变原。 
	给定两个cfg判定是否产生同一个语言。 （不可判定）
	每个cfl是可判定的。 


可判定即可停机， 不会出现死循环是可计算

图灵机的可计算问题
	图灵机模拟形式系统， 对等 lambda calculus. 
	检查一个图灵机是否接受一个串，（是不可判定的），反证法。 构造悖论。 如果证明机返回接受我拒绝， 如果证明机返回拒绝我接受。 
	看证明机， 能不能判定我是否接受一个w。 证明没有这样的证明机。 


可识别只能证明是这个东西， 不能证明不是这个东西。 可判定是可识别的特例。 

A和A的初都是可识别的， 那么他们是可判定的。 
图灵机的补不是图灵机可识别的。 存在非图灵可识别语言。 

语言类之间的关系

正则语言  上下文无关  图灵可判定语言  图灵可识别语言（递归可枚举）
  非图灵语言

	是不是可停机是不可判定。 

	图灵机的空性问题。 也是不可判定的。 构造一个图灵机只识别w。 则图灵机可判定w， 反证。 

检查一个图灵机是否有一个正则自动机？是不可判定的。 

线性界限自动机  是可判定的。 
E LBA是不可判定的。 

波斯特对应问题
归约  
可判定语言类在归约下是封闭的。 


rice定理。 
指标集是不可判定的。 


DTM决定性图灵机运行时间由输入长度来确定。 

log  幂函数的  反面。 
In mathematics, the logarithm is the inverse function to exponentiation. 
e (mathematical constant)

Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. Big O is a member of a family of notations invented by Paul Bachmann,[1] Edmund Landau,[2] and others, collectively called Bachmann–Landau notation or asymptotic notation.

In computer science, big O notation is used to classify algorithms according to how their run time or space requirements grow as the input size grows

https://en.wikipedia.org/wiki/Big_O_notation


输入长度与编码有关
输入规模  与  问题中的自然参数有关。 与编码无关。 



“P vs NP” 这个问题有它的理论价值，它是有趣的问题，里面的有些思路有启发意义，值得花些时间来了解。但计算机科学界长久以来都严重夸大它的重要性，把一个很普通的问题捧上了天，吹得神乎其神。

再加上图灵机模型在计算理论界的广泛使用，使得这门学问显得异常艰深。很多人看到图灵机就晕了，在课程上蒙混过关，考试完了就全忘了，根本无法理解里面的实质内容。正是因为很多人的不明觉厉，使得“P vs NP”登上了它在 CS 界的宝座。


“无穷”对于现实的问题是没有意义的。


微积分的重要性就是摒弃了无限这虚无飘渺的东西。 
计算复杂性概念

多带单带  单带空间上的限制带来复杂性。 
多带变单带：时间平方。 
非确定性与确定性图灵： 指数 。 


复杂性分类： 
P类 polynomial time
有向图可达性
	蛮力搜索。 
	宽度优先搜索。 
判断互素：
	蛮力法
	辗转相除法

识别是不是ｃｆｌ：
	蛮力法：
	动态规划：

NP类："nondeterministic polynomial time"
	哈密顿路径（送快递）：过每个点一次，且恰好一次。 
	每次问有没有， 有删边。 搜索归为判定问题。 
	验证机：

语言有多项式时间验证机， 就是NP类
	非确定图灵可判定语言。 
	团问题
	子集和问题（背包问题）

coNP类（补NP）  EXP类（指数类）


P成员资格可以快速判定的语言类
NP成员资格可以快速验证的语言类



空间复杂性 （space complex）
空间复杂性 与  时间复杂性。 

萨维奇定理
用确定性空间来模拟非确定型空间只有平方的增长。 
pspace类


亚线性空间比p还小（L类， NL 类）sub-linear
设多带  一条只读带， 一条可读写带， 一条输出带

NSPACE = CONSPACE


空间可构造

apt install clisp
clisp

  i i i i i i i       ooooo    o        ooooooo   ooooo   ooooo
  I I I I I I I      8     8   8           8     8     o  8    8
  I  \ `+' /  I      8         8           8     8        8    8
   \  `-+-'  /       8         8           8      ooooo   8oooo
    `-__|__-'        8         8           8           8  8
        |            8     o   8           8     o     8  8
  ------+------       ooooo    8oooooo  ooo8ooo   ooooo   8

Welcome to GNU CLISP 2.49.92 (2018-02-18) <http://clisp.org/>

Copyright (c) Bruno Haible, Michael Stoll 1992-1993
Copyright (c) Bruno Haible, Marcus Daniels 1994-1997
Copyright (c) Bruno Haible, Pierpaolo Bernardi, Sam Steingold 1998
Copyright (c) Bruno Haible, Sam Steingold 1999-2000
Copyright (c) Sam Steingold, Bruno Haible 2001-2018

Type :h and hit Enter for context help.

[1]> (+ 3 4)
7
[2]> (+ 3 4 8)
15




Computability theory asks questions such as: do there exist problems unsolvable by any
effective procedure — unsolvable by any program in any conceivable programming language on any computer?

 computability theory is concerned with the boundary between computability and uncomputability, and addresses questions such as:
• Can every precisely stated problem be solved by some effective procedure?
• What is the class of problems that can be solved by effective procedures and its
basic properties?
• What is the relationship between various problems that cannot be solved by effective procedu


There are many other notions of effective procedure than Turing machines, e.g.,
• Recursive functions as defined by Kleene [98]
• The lambda calculus approach to function definitions due to Church [22, 23].
• Random access machines [163]
• Markov algorithms [115]


the Church-Turing thesis is sometimes expressed in the following form:
1. All reasonable formalizations of the intuitive notion of effective computability are
equivalent;

. Turing machine computability is a reasonable formalization of effective computability.

effective procedure= algorithm


处处停机  可计算

On data representation 编码  能编回来能展现回来。 

 Given a set D, and a subset S ⊆ D. S is effectively decidable iff there
is an effective procedure which, when given an object x ∈ D, will eventually answer “yes”
if x ∈ S, and will eventually answer “no” if x 6∈ S.

 Given a set D, and a subset S ⊆ D. S is effectively enumerable iff
there is an effective procedure which, when given an object x ∈ D, will eventually answer
“yes” if x ∈ S, and will answer “no” or never terminate if x 6∈ S.


图灵的证明过程和哥德尔对不完备性定理的证明过程有很大的相似性，都需要对符号系统进行数字化的编码，同时，都要通过对角线方法来获得一个命题：我是不可判定的。

对角线方法
假设实数集可数。则实数能与自然数一一映射。
0 0.282728424871……1 
1.442282215825……2 
0.010101010101……3 
2.428245294258……4 
1.276343024642……5 1.234567891011…………可是我们可以创造一实数，整数部分与0不同，第一位与1的不同，第二位与2的不同……(如1.52744……等)，于是这个实数与以上列出来的都不相等，矛盾。所以实数集是不可数的。


Recall that computability theory is concerned with questions such as whether a problem is solvable at all, assuming one is given unlimited amounts of space and time. In
contrast, complexity theory is concerned with questions such as whether a problem can
be solved within certain limited computing resources, typically space or time.


to address such questions, one must have a precise definition of space and time costs.
Granted that, complexity theory asks questions such as:
• Which problems can be solved within a certain limit of time or space, and which
cannot?
• Are there resource limits within which a known combinatorial problem definitely
cannot be solved?
• Are there problems which inherently need more resources than others?
• What characteristics of problems cause the need for certain amounts of resources?
• What is the class of problems solvable within certain resource limits, and what are
the basic properties of this class?
• Given a problem, what is the complexity of its best algorithm?
• Do best algorithms always exist?
• Does adding more resources allow one to solve more problems



. There are a few problems whose exact complexity can be identified, but very few

Logspace ⊆ nlogspace ⊆ ptime ⊆ nptime ⊆ pspace = npspace ⊂ rec ⊂ re


At the conference Hilbert presented 23 unsolved mathematical problems. One of these,
the Entscheidungsproblem (decision problem), was described as follows:10
The Entscheidungsproblem is solved if one knows a procedure which will permit
one to decide, using a finite number of operations, on the validity, respectively the
satisfiability of a given logical expression.



In 1931 G¨odel showed his celebrated Incompleteness Theorem [54] stating, roughly,
that for any consistent, sufficiently strong formalization of number theory, there are
true propositions which cannot be proved in that formalization. To the experts this
result made it seem highly unlikely that the Entscheidungsproblem could have a positive
solution

 λ-expressions and Turing machines,

形式系统等价
 proved by Kleene, Turing, and others. In fact, one can
write compilers that turn a program in one formalism into a program in one of the
other formalisms that computes the same function, supporting what we have previously
called the Church-Turing thesis.

起了个复杂的名字

The first systematic investigation of time and space hierachies is due to Hartmanis,
Lewis, and Stearns [65, 64, 109] in the 1960’s, who coined the term “computational
complexity” for what we call complexity theory in this book

构造形式系统对等
proving the equivalence of WHILE with a variety of other computation models.



The WHILE Language
	Expressions 3 E, F ::= X (for X ∈ Vars)
		| d (for atom d)
		| cons E F   ###  This operation is called cons (short for “construct”.)
		| hd E       ### head 
		| tl E       ### tail
		| =? E F
	Commands 3 C, D ::= X := E
		| C; D
		| while E do C
	Programs 3 P ::= read X; C; write Y

reverse:

read X;
Y := nil;
while X do
	Y := cons (hd X) Y;
	X := tl X;
write Y


For reverse, if X is initially bound to input
	(d0.(d1.(···.(dn−1.(dn.nil))···)))
then Y is bound to
	(dn.(dn−1.(···.(d1.(d0.nil))···)))



The expression =? E F evaluates to true, if E and F evaluate to the same value, and to
false otherwise. Thus =? (nil.nil) (nil.nil) evaluates to true, and =? (nil.nil)
nil evaluates to false.




Definition 2.1.2 The function | •| : ID → IN defined by:
|d| =(1 if d ∈ A
|d1|+|d2| if d = (d1.d2)
denotes the size of a data value d ∈ ID


, e.g., (nil.nil) for a, (nil.(nil.nil)) for b, and ((nil.nil).nil) for c.


用while 模拟 if else
Z := E; (* if E then C *)
while Z do { Z := false; C };

Z := E; (* if E then C1 else C2 *)
W := true;
while Z do { Z := false; W := false; C1 };
while W do { W := false; C2 };



 Lists
As one can see from the example in subsection 2.1.3, elements of ID sometimes have
deeply nested parentheses that are hard to read; one has to resort to counting to parse
an element like ((a.(b.nil)).((d.(e.nil)).nil)).
Often the nesting has a certain regular structure, because we often express a list of
elements d0, d1,. . . , dn−1, dn as the tree (d0.(d1.(···.(dn−1.(dn.nil)) ···))). For
instance (a.(b.nil)) represents the list consisting of elements a, b. Therefore it would
be particularly convenient to have a short notation for this form. Hence the idea is to
use the notation (d0 ···dn) for the tree (d0.(d1.(···.(dn−1.(dn.nil)) ···))). Then the
tree (a.(b.nil)) can be written (a b) in short notation and, as another example, the
tree ((a.(b.nil)).((d.(e.nil)).nil) can be written ((a b) (d e)).
This is introduced in the following definition



 The function | •| : ID → IN defined by:
|d| =
(1 if d ∈ A
|d1|+|d2| if d = (d1
.d2)
denotes the size of a data value d ∈ ID. 


Define n = niln, where
nil0 = nil = ()
niln+1 = (nil.niln
) = (nil ... nil
| {z }
n+1 times
)
and let N = {n|n ∈ IN}. The elements of N are called numerals.

WHILE has only one atom, so how can we compute with numbers? One idea is to
represent the number n by a list of length n.




read X; (* succ *)              read X; (* pred *)
    Y := cons nil X;                Y:=tl X;
write Y                         write Y



read XY; (* add X Y *)
	X := hd XY;
	Y := tl XY;
	while X do
		Y := cons nil Y;
		X := tl X;
write Y

语法糖
Syntactic sugar: some useful macro notations

 cons* E1 ··· En



A compiler is a program transformer which takes a program and translates it into an
equivalent program, possibly in another language



An interpreter takes a program and its input data, and returns the result of applying the program to that input.
Language L is equivalent to language M, written L ≡ M, if language L and language M
can simulate each other. 



• : WHILE−programs → WHILE−data


Mapping WHILE programs to their data representations.

read Vi; C; write Vj = ((vari)C(varj))
C;D = (;CD)
while E do C = (whileEC)
Vi:=E = (:= (vari)E)
Vi = (vari)
d = (quoted)
cons E F = (consEF)
hd E = (hdE)
tl E = (tlE)
=? E F = (=? EF)


Suppose we are given three programming languages:
• A source language S,
• A target language T, and
• An implementation language L.


In order to be meaningful a diagram must be “well-formed,” that is satisfy some
natural constraints:
1. All languages appearing bottom-most in the diagram must be executable (either
because they are machine languages, or because implementations are known to
exist even though not shown in the diagram).
2. Let us define language L to match language M, written L v M, to mean that any
L-program is also an M-program, and has the same semantics. A special case: L v
L, that is, any language matches itself.
3. The second constraint is that any subdiagram of either of the following two forms:



Self-interpretation: Universal Programs for WHILE and I


A partial function f : ID → ID⊥ is WHILE computable iff there is a
WHILE program p such that f = [[p]], i.e. for all d,e ∈ ID:
1. If f (d) = ⊥ then [[p]](d) = ⊥.
2. If f (d) = e ∈ ID then [[p]](d) = e.


For a language L
if there is some Turing Machine that accepts every string in L
and rejects every string not in L, then L is a decidable
language
if there is some Turing machine that accepts every string in L
and either rejects or loops on every string not in L, then L is
Semi-decidable or computably enumerable



L = {0n1n: n ≥ 0} is not regular.
limitation of FA related to fact that they can only “remember” a bounded amount of information。



Automaton scans an input from left to right - at each step it may push a symbol onto the stack, or pop the stack. It cannot read other elements of the stack.

Automaton scans an input from left to right - at each step it may push a symbol onto the stack, or pop the stack. It cannot read other elements of the stack.



Every CFL is generated by a CFG in Chomsky Normal Form

Proof: Transform any CFG into equivalent CFG in CNF. 4 steps:
add a new start symbol, which can produce prior start
remove “-productions” A → 
eliminate “unit productions” A → B
convert remaining rules into proper form


abcdefg convert to a(b(c(d(e(fg)))))


学习各形式系统都有那些限制，新系统解决了那些限制 。 
limitation of NPDA related to fact that their memory is stack-based (last in, first out)


everything we can compute on a physical
computer can be computed on a Turing
machine.



The real numbers R are NOT countable (they are
“uncountable”).
How do you prove such a statement?
assume countable (so there exists function f
from N onto R)
derive contradiction (“construct” an element
not mapped to by f )
technique is called diagonalization (Cantor)


Theorem
HALT is not decidable (undecidable).
Proof will involve the following
Suppose there’s some TM H that decides HALT. Using this we will get a contradiction. You’ll need to believe that TMs can simulate other TMs, also can be composed with each other.



Language Decided
We say a TM decide a language L if it accepts all strings in L and rejects all strings not in L. (Here, the TM should not accept any string not in L, but when we say a TM accept a word w, it may accept any other word also)

Language Recognized
We say a TM recognizes language L if it accepts all strings in L. It may or may not reject any string not in L- i.e., it might go into an infinite loop in case of non-acceptance. (It will never accept a string not in L)


rice定理等价停机问题
In this note I will show a theorem which states that a very large family of
problems are all undecidable. Our result, known as Rice’s theorem after Henry
Rice who proved the result in 1953 [2], states that if S is a non-trivial property
of Turing-recognizable languages, then the problem
Given a TM M, does L(M) have the property S?
is undecidable.
What's a trivial property?

A "trivial" property is one that holds either for all languages or for none.
牛逼 

David Richerby
top 0.10% overall
Apparently, this user prefers to keep an air of mystery about them
https://cs.stackexchange.com/users/9550/david-richerby

好书
structure and interpretation of computer programs pdf



 These models of computation can’t solve every problem.


what does this do?
((lambda (x) (x x))
(lambda (x) (x x)))



(define (troll)
(if (halt? troll)
; if halts? says we halt, infinite-loop
((lambda (x) (x x)) (lambda (x) (x x)))
; if halts? says we don't, return a value
#f))
(halt? troll)



Run it with a copy of itself.
(define (fact inner-fact n)
(if (= n 0)
1
(* n
(inner-fact inner-fact (- n 1)))))



I have never done anything “useful.”
— Godfrey Harold Hardy (1877–1947),
A Mathematician’s Apology (1940)


What This Course Is All About
Computation: What is computation?
Computability: What can be computed?
• There are problems that cannot be computed.
• In fact, most problems cannot be computed.


Recommended reading
* Hopcroft, J.E., Motwani, R. & Ullman, J.D. (2001). Introduction to automata theory, languages, and computation. Addison-Wesley (2nd ed.).
* Hindley, J.R. & Seldin, J.P. (2008). Lambda-calculus and combinators, an introduction. Cambridge University Press (2nd ed.).
Cutland, N.J. (1980). Computability: an introduction to recursive function theory. Cambridge University Press.
Davis, M.D., Sigal, R. & Weyuker, E.J. (1994). Computability, complexity and languages. Academic Press (2nd ed.).
Sudkamp, T.A. (2005). Languages and machines. Addison-Wesley (3rd ed.).



What This Course Is All About (concluded)
Applications: Intractability results can be very useful.
• Cryptography, digital currency, and security.
• Approximations.
• Pseudorandom number generation and
derandomization.
• Conjectures about nature.



指数增长
1 1 9 362,880
2 2 10 3,628,800
3 6 11 39,916,800
4 24 12 479,001,600
5 120 13 6,227,020,800
6 720 14 87,178,291,200
7 5040 15 1,307,674,368,000
8 40320 16 20,922,789,888,000



What Is Computation?
• That can be coded in an algorithm.a
• An algorithm is a detailed step-by-step method for
solving a problem.
– The Euclidean algorithm for the greatest common
divisor is an algorithm.
– “Let s be the least upper bound of compact set A” is
not an algorithm.
– “Let s be a smallest element of a finite-sized array”
can be solved by an algorithm.
– How about passing the Turing test?



• A Turing machine (TM) is a quadruple M = (K, Σ, δ, s).
• K is a finite set of states.b
• s ∈ K is the initial state.
• Σ is a finite set of symbols (disjoint from K).
Σ includes  (blank) and ✄ (first symbol).c

δ : : K × Σ → (K ∪ {h, “yes”, “no”}) × Σ × {←, →, −} is a transition function.
–
← (left),
→ (right), and
− (stay) signify cursor movements.

Given current state q ∈ K and current symbol σ ∈ Σ,
δ(q, σ)=(p, ρ, D).
– It specifies:
∗ The next state p;
∗ The symbol ρ to be written over σ;
∗ The direction D the cursor will move afterwards


• For convenience, δ(q, ✄)=(·, ✄, →) for every q ∈ K.
– So the cursor never falls off the left end of the string.
• Think of the program as lines of codes:
δ(q1, σ1)=(p1, ρ1, D1),
δ(q2, σ2)=(p2, ρ2, D2),
.
.
.
δ(qn, σn)=(pn, ρn, Dn).


• The specification of a configuration is sufficient for the
computation to continue as if it had not been stopped.
– What does your PC save before it sleeps or
hibernates?
– Enough for it to resume the work later.
• Similar to the concept of state in Markov processes.


configuration: 用于保存现场。 
A configuration is a triple (q, w, u):
– q∈K.
– w∈Σ∗ is the string to the left of the cursor(inclusive).
–u∈Σ∗ is the string to the right of the cursor.
• Note that (w, u) describes both the string and the cursor
position.


“Physical” Interpretations
• The tape: computer memory and registers.
– Except that the tape can be lengthened on demand.
• δ: program.
– A program has a finite size.
• K: instruction numbers.
• s: “main()” in the C programming language.
• Σ: alphabet, much like the ASCII code.


Given current state q ∈ K and current symbol σ ∈ Σ,
δ(q, σ)=(p, ρ, D).
– It specifies:
∗ The next state p;
∗ The symbol ρ to be written over σ;
∗ The direction D the cursor will move afterwards


• Assume the state is q and the symbol under the cursor σ.
• The line of code that matches (q, σ) is executed.a
• Then the process is repeated.


The Concept of Configuration
•
A configuration a is a complete description of the
current state of the computation



• A string is a palindrome if it reads the same forwards and backwards (e.g., 001100).


Theorem 1 (Hennie, 1965) palindrome on single-string
TMs takes Ω^(2) steps in the worst case.

• This happens rarely and is model dependent.
– Searching, sorting, palindrome, matrix-vector
multiplication, etc.

Stephen Kleene (1909–1994)


The two words in the language I most respect
are Yes and No.
— Henry James (1843–1916),
The Portrait of a Lady (1881)


• Let
M be a TM such that for any string
x:
– If x∈L, then M(x) = “yes.”
– If x∈L, then M(x) = “no.” 
• We say M decides L.

• If there exists a TM that decides
L, then L is said to be recursive a or decidable.


• The set of palindromes over any alphabet is recursive.
a
– palindrome cannot be solved by finite state
automata.
– In fact, finite-state automata are equivalent to
read-only, right-moving TMs.



• The set of C programs that do not contain a while, a
for, or a goto is recursive.
a
• But, the set of C programs that do not contain an
infinite loop is not recursive (see p. 137).

a There is a program that will halt and it returns “yes” if and only if
the input C code does not contain any of the keywords. bSo there is no algorithm that will answer correctly in a finite amount
of time if a C program will run into an infinite loop on some inputs.

能识别但不能判定的：
• If L is accepted by some TM, then
L is said to be recursively enumerable or semidecidable.


Emil Post (1897–1954)

 The set of C program-input pairs that do not run into
an infinite loop is recursively enumerable.
– Just run its binary code in a simulator environment.
– Then the simulator will terminate if and only if the C
program will terminate.
– When the C program terminates, the simulator
simply exits with a “yes” state.
• The set of C programs that contain an infinite loop is
not recursively enumerable.
a。



Church’s Thesis or the Church-Turing Thesis
(concluded)
• Many other computation models have been proposed.
– Recursive function,
a
λ calculus,
b boolean circuits,
c
formal language,
d assembly language-like RAM,
e
neural networks,
f and extensions of the Turing
machine (more strings, two-dimensional strings, etc.).
• All have been proved to be equivalent.



Decision problems
Entscheidungsproblem means “decision problem”. Given
! a set S whose elements are finite data structures of
some kind
(e.g. formulas of first-order arithmetic)
! a property P of elements of S
(e.g. property of a formula that it has a proof)
the associated decision problem is:
find an algorithm which
terminates with result 0 or 1 when fed an element s ∈ S
and yields result 1 when fed s if and only if s has property P.


处处停机
Algorithms, informally
No precise definition of “algorithm” at the time Hilbert
posed the Entscheidungsproblem, just examples.
Common features of the examples:
! finite description of the procedure in terms of
elementary operations
! deterministic (next step uniquely determined if there
is one)
! procedure may not terminate on some input data,
but we can recognize when it does terminate and
what the result is.


Common features of the examples:
! finite description of the procedure in terms of
elementary operations
e.g. multiply two decimal digits by
looking up their product in a table
! deterministic (next step uniquely determined if there
is one)
! procedure may not terminate on some input data,
but we can recognize when it does terminate and
what the result is.

The Halting Problem
is the decision problem with
! set S consists of all pairs (A, D), where A is an algorithm and
D is a datum on which it is designed to operate;
! property P holds for (A, D) if algorithm A when applied to
datum D eventually produces a result (that is, eventually
halts—we write A(D)↓ to indicate this).

多带图灵机

Turing Machines with Multiple Strings

Time seemed to be the most obvious measure of complexity.
— Stephen Arthur Cook (1939–)



I keep bumping into that silly quotation
attributed to me that says
640K of memory is enough.


Michael O. Rabin
Dana Stewart Scott



Universal Turing Machinea：：：
U(M; x) = M(x).
U is like a modern computer, which executes any valid
machine code, or a Java virtual machine, which executes
any valid bytecode.




H Is Not Recursivea
• Suppose H is recursive.
• Then there is a TM MH that decides H.
• Consider the program D(M) that calls MH:
1: if MH(M; M) = “yes” then
2:  ; {Writing an infinite loop is easy.}
3: else
4: “yes”;
5: end if


Self-Loop Paradoxes

规约即转换
• Suppose we are asked to prove that
L is undecidable.
• Suppose L (such as H) is known to be undecidable.
• Find a computable transformation R (called reduction a) from L to
L such that 
b ∀ x { x ∈ L if and only if R ( x ) ∈ L }.
• Now we can answer “
x ∈ L?” for any
x by answering
“ R ( x ) ∈ L?” because it has the same answer.
• L is said to be reduced to
L.


If
L is recursive, then so is L¯. （L complement）



RE: The set of all recursively enumerable languages.
coRE: The set of all languages whose complements are recursively enumerable.
R: The set of all recursive languages.

Note that coRE is not RE(complement).

trivial property:::::
– Answer to a trivial property is always “yes”or always“no.”



Undecidability in Logic and Mathematics
• First-order logic is undecidable (answer to Hilbert’s
(1928) Entscheidungsproblem).
a
• Natural numbers with addition and multiplication is
undecidable.
b
• Rational numbers with addition and multiplication is
undecidable.
c



Elementary theory of groups is undecidable.


Julia Hall Bowman Robinson (1919–1985)

Alfred Tarski (1901–1983)
香农定律：
如果把网络带宽比喻为车道宽度，那么网速就好比汽车在车道上行驶的速度。汽车在车道上行驶得快或者不快，要受限于车道宽度的大小，车道上正有多少辆汽车在行驶等诸多干扰性因素。

图中标明了香农三定理的位置，第一定理和第三定理对应的是压缩理论，而第二定理也就是鼎鼎有名的香农容量，对应的是传输理论。香农第一定理——无失真信源编码定理香农第一定理在编码领域的地位，无异于倚天屠龙记中的九阳神功。它给出了在无损情况下，数据压缩的临界值。不要小瞧这简简单单的一句话，正因为给出了理论上的下界，所以才会产生各式各样的编码办法。在无损压缩的情况下，压缩任何东西所需要的比特数都大于香农第一定理所给出的值。可以说，任何压缩方法都是在这个圈子里兜兜转转，是跳不出来的。接下来，我详细说一下香农第一定理的数学化表述：

The Relation between Nondeterministic and Deterministic Space Is Only Quadratic

Reductions and Completeness


Degrees of Difficulty
• When is a problem more difficult than another?
• B reduces to A if:
– There is a transformation R which for every problem
instance x of B yields a problem instance R(x) of A.a
– The answer to “R(x) ∈ A?” is the same as the answer to “x ∈ B?”
– R is easy to compute.
• We say problem A is at least as hard asb problem B if B reduces to A.


 This makes intuitive sense: If A is able to solve your
problem B after only a little bit of work of
R, then A
must be at least as hard.
– If A is easy to solve, it combined with
R (which is also easy) would make B easy to solve, too.
a
– So if B is hard to solve, A must be hard (if not harder), too!


• Our definition says in this case B is a special case of A.
b
• Hence A is harder.

hamiltonian path

hamiltonian path



The required properties of a satisfactory formal system are that it be

complete -- it must be possible either to prove or to disprove any proposition that can be expressed in the system.
consistent -- it must not be possible to both prove and disprove a proposition in the system.



Kurt Gödel explored the very notions of completeness and consistency. He invented a numbering scheme (Gödel numbers) that allowed him to express proofs as numbers (much as we might consider a computer program to be a very large binary number). He was able to prove the following result:

If it is possible to prove, within a formal system, that the system is consistent, then the formal system is not, in fact, consistent.

Or, equivalently,

If a formal system is consistent, then it is impossible to prove (within the system) that it is consistent.




We prefer to give up completeness rather than consistency, because in a consistent system any proposition can be proven.


Gödel left open the possibility that we could somehow distinguish between the provable propositions and the unprovable ones. Ideally, we would like to have a mechanical (algorithmic) theorem-proving procedure. Alan Turing invented Turing machines in an attempt to solve this problem. With the Halting Problem, he showed that we cannot, in all cases, distinguish between soluable and insoluable problems.


Other mathematicians, working with very different models of computation, ended up with very similar results. One of these was Alonzo Church, who invented recursive function theory.


 recursive function theory



 The textbook describes these functions as being over the natural numbers I={0,1,2,3,...}. A better way to look at recursive functions, though, is as pure symbol systems. Numbers are not used in the system; rather, we use the system to construct both numbers and arithmetical functions on numbers. In other words, it's a different numbering system, in the same way that Roman numerals are different. The correspondence goes like this:

z(x)=0, s(z(x))=1, s(s(z(x)))=2, s(s(s(z(x))))=3, ...




The zero function: z(x)=z(y) for all x,yis a member ofI. (This is our "zero"; it is written as a function so we don't have to introduce constants into the system.)
The successor function: s(x). Informally, this means "x+1". Formally, it doesn't "return a value", it just sits there: the result of s(x) is s(x).
For convenience, we make the following "abbreviations":
0 is shorthand for z(x).
1 is shorthand for s(z(x)).
2 is shorthand for s(s(z(x))).
3 is shorthand for s(s(s(z(x))).
...and so on.
The projector functions:
p1(x) = x.
p1(x, y) = x.
p2(x, y) = y.




Composition and Recursion

The recursion must be guaranteed to terminate. To ensure this, the function must carry along an extra parameter that is "decremented" each time the function is called (s(x) is replaced by x), and halts the recursion when it reaches "zero" (z(x)). That is,
f(..., z(x)) = ...

f(..., s(x)) = ... f(..., x), ...

The recursive function must appear only once in the definiens (right hand side of the definition). This restriction prevents various forms of "fancy" recursion.




Primitive Recursion
The second building operation is called primitive recursion. To those not used to it, it can be far from intuitive; to those who have practiced with it, it is fundamental and elegant.

Function h is defined through functions f and g by primitive recursion when

h(x,0) = f(x)
h(x,s(y)) = g(x,h(x,y))



The key new feature here is the use of a previously defined function, add, in the definition of a new function. We skip the step of playing around with the pi functions to pick out the right parts, and go right to the simplified form.

multiply(x, s(z(x))) = x
multiply(x, s(y)) = add(x, multiply(x, y))



阿克曼函数
1920年代后期，数学家大卫·希尔伯特的学生Gabriel Sudan和威廉·阿克曼，当时正研究计算的基础。Sudan发明了一个递归却非原始递归的Sudan函数。1928年，阿克曼又独立想出了另一个递归却非原始递归的函数。[1]


I've always used the two terms interchangeably, but your textbook makes a distinction, so here it is.

Turing's thesis. Anything that is computable can be computed by a Turing machine. There does not and cannot exist a machine that can compute things a Turing machine cannot compute.

Church's thesis. All the models of computation yet developed, and all those that may be developed in the future, are equivalent in power. We will not ever find a more powerful model.


Complexity Theory
Complexity theory concerns itself with two kinds of measures: time and space.


Time complexity is a measure of how long a computation takes to execute. For a Turing machine, this could be measured as the number of moves required to perform a computation. For a digital computer, it could be measured as the number of machine cycles required for the computation.

Space complexity is a measure of how much storage is required for a computation. For a Turing machine, the obvious measure is the number of tape squared used; for a digital computer, the number of bytes used.


For any given input size, different inputs typically require different amounts of space and time. Hence we can discuss for either the average case or for the worst case. Usually we are interested in worst-case complexity because

It may difficult or impossible to define an "average" case. For many problems, the notion of "average case" doesn't even make sense.
 
It is usually much easier to compute worst-case complexity.
 


Polynomial-Time Algorithms
A polynomial-time algorithm is an algorithm whose execution time is either given by a polynomial on the size of the input, or can be bounded by such a polynomial. Problems that can be solved by a polynomial-time algorithm are called tractable problems.

For example, most algorithms on arrays can use the array size, n, as the input size. To find the largest element in an array requires a single pass through the array, so the algorithm for doing this is O(n), or linear time.

Sorting algorithms usually require either O(n log n) or O(n^2) time. Bubble sort takes linear time in the best case, but O(n2) time in the average and worst cases. Heapsort takes O(n log n) time in all cases. Quicksort takes O(n log n) time on average, but O(n2) time in the worst case.


Probably all the programming tasks you are familiar with have polynomial-time solutions. This is not because all practical problems have polynomial-time solutions. Rather, it is because your courses and your day-to-day work have avoided problems for which there is no known practical solution.



Integer Bin Packing
Suppose we are given a set of n positive integers. Our task is to arrange these integers into two piles, or "bins", so that the sum of the integers in one pile is equal to the sum of the integers in the other pile.

For example, given the integers

(19, 23, 32, 42, 50, 62, 77, 88, 89, 105, 114, 123, 176)

These numbers sum to 1000. Can they be divided into two bins, bin A and bin B, such that the sum of the integers in each bin is 500?




Boolean Satisfiability
Suppose you have n Boolean variables, named A, B, C, ..., and you have an expression in the propositional calculus (that is, you can use and, or, and not to form the expression.) Is there an assignment of truth values to the variables (e.g. A=true, B=true, C=false, ....) that will make the expression true?



Additional NP Problems
The following problems all have a polynomial-time solution on a nondeterministic machine, but an exponential-time solution on a deterministic machine. There are literally hundreds of additional examples.

The travelling salesman problem
A salesman, starting in Harrisburg, wants to visit every capital city in the 48 continental United States, returning to Harrisburg as his last stop. In what order should he visit the capital cities so as to minimize the total distance travelled?

The Hamiltonian circuit problem
Every capital city has direct air flights to at least some other capital cities. Our intrepid salesman wants to visit all 48 capitals, and return to his starting point, taking only direct air flights. Can he find a path that lets him do this?

Equivalence of regular expressions
Do two distinct regular expressions represent the same language?

Intersection of finite automata
Given a set of finite automata M1, M2, M3, ..., Mn, all over the same alphabet A, is there some string in A* that is accepted by all of these automata?

Linear programming
You have on hand X amount of butter, Y amount of flour, Z eggs, etc. You have cookie recipies that use varying amounts of these ingredients. Different kinds of cookies bring different prices. What mix of cookies should you make in order to maximize profits?

This type of problem is sufficiently important that entire college courses are devoted to it, usually in the College of Business.




图灵机对纸笔进行数学运算的过程。 打字机。 


https://wiki.python.org/moin/TimeComplexity

十进制变2进制  一直除


表达式转前缀表达


表达式转换  

In mathematics and computer science, a class of objects or methods exhibits recursive behavior when it can be defined by two properties:

A simple base case (or cases) — a terminating scenario that does not use recursion to produce an answer
A recursive step — a set of rules that reduces all successive cases toward the base case.
For example, the following is a recursive definition of a person's ancestor. One's ancestor is either:

One's parent (base case), or
One's parent's ancestor (recursive step).




递归和stack一个东西， 不同表现。 
调用栈。 


递归和树是否等价。 



虚拟货币运作之本质即是将每笔交易记载于区块中，形成一条链性结构，然而这样的「直线特性」也就成了最佳的溯源工具。因此与其说虚拟货币具有匿名性，不如说它只具有伪匿名性（pseudo-anonymity）。也就是虽然表面上具有匿名性，但实际上透过层层破解及科技溯源仍可找到实际使用者位置。


树
   画树干
   左转画树干reset position
   右转画树干reset pisition 
   reset pisition




sierpinski谢尔宾斯基三角形


汉诺塔

把塔  从三个柱子的最左边一个柱子， 移到最右边一个柱子上。 要求大盘不能在小盘上。 
是个递归，把下一个和上一个移出来， 组成一个组，成上一个， 一直进行下去，到次最大， 然后把次最大的组成一个组， 
1号  2号  3号
把顶上的移到2号， 移最大到3， 
把顶上移到1号， 移最大到3， 
把顶上移到2号 移最大到3号， 




兑最少货币。 
贪心策略


elbonina.
找零兑换问题



最短路径 是动态规划


分阶段， 每一阶段的值， 下一阶段到上一阶段的值，一直递归下去，找到最优。

每一阶段都有状态，  

三峡学院 关文忠 运筹学  很好《运筹学》、《统计学
动态规划 dynamic Programming 是求解多阶段决策过程multistep decision process最优化的一种数学方法。 它将问题的整体按时间或空间的特征分成若干个前后衔接的时空阶段， 把多阶段决策问题表示 为前后有关的一系列单阶段决策问题， 然后逐个求解， 从而求出整个问题的最优决策序列。 它强调了时间和空间的连续性。 
贝尔曼
Dynamic programming is both a mathematical optimization method and a computer programming method. The method was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics.

管理运筹学 关文忠，韩宁鑫主编

1阶段  2状态变量  3决策变量  4 策略 5 状态转移方程 6 指标函数与最优值函数 7 边界条件


阶段变量
每阶段节点可称状态
每一状态和下一阶段 允许策略的集合  决策变量。



策略 （决策集）
最优化原理是动态规划的基本原理， 最优策略的子策略也是最优的。 


动态规划的基本思想
f(i)= min(d(i,j) + f(j))
f(e) = 0
动态规划的关键在于写出基本递推关系式， 和恰当的边界条件。 



在多阶段决策过程中， 即把当前阶段和未来阶段分开， 又把当前效益和未来阶段结合起来。 

从前往后推  和 从后往前推


s1={A}  s2 = {B1, B2} s3={C1, C2, C3, C4} s4={D1, D2}



动态规划 有逆序  有顺序解法。 


资源分配问题  工厂是阶段。 资源数量是状态。 状态之间存在的配对关系是策略。 
设备负何问题  季度是阶段。 完好数量是状态。 状态之间可存在的配对关系是策略。 
生产库存问题  
背包问题。 
非线性规划求解。 




