https://www.seas.harvard.edu/courses/cs152/2021sp/resources.html
The Curry-Howard Isomorphism
Resources
Text books
A number of excellent books and on-line resources overlap with the course's content and can provide alternate explanations despite differences in notation and approach. Let the instructor know if you have trouble finding the intersection between these resources and the course content.

"Types and Programming Languages" by Benjamin C. Pierce, MIT Press, 2002.
Available on reserve at the library.
"Software Foundations" by Benjamin C. Pierce et al., Volume 1: Logical Foundations and Volume 2: Programming Language Foundations.
Available as literate Coq files.
Also available as literate Agda files thanks to Philip Wadler, Wen Kokke and Jeremy Siek.
"Practical Foundations for Programming Languages" by Robert Harper, Cambridge University Press, 2013.
Draft available on Harper's website.
"Concepts in Programming Languages" by John C. Mitchell, Cambridge University Press, 2003.
Available online through Harvard University Libraries eContent Collection.
"The Formal Semantics of Programming Languages" by Glynn Winskel, MIT Press, 1993.
Available on reserve at the library.
"Programming Languages: Application and Interpretation" by Shriram Krishnamurthi.
There are two editions, both available on the author's website: http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/.
OCaml resources
Installation: https://ocaml.org/docs/install.html
Tools: https://github.com/realworldocaml/book/wiki/Installation-Instructions
This link gives instructions for installing things like Tuareg (a useful emacs mode) and Merlin (advanced IDE features).

Installing Tuareg is pretty simple and will make your OCaml coding experience a lot nicer (though it's of course not necessary). Merlin is probably overkill unless you know what you're doing.

Learning:
Standard library documentation: http://caml.inria.fr/pub/docs/manual-ocaml/libref/index.html
The following documentation may be particularly useful as you work on your assignments.
Sets: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.Make.html
Maps: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.Make.html
Everything you need to know and more: http://caml.inria.fr/pub/docs/manual-ocaml/index.html
Code examples: http://ocaml.org/learn/tutorials/99problems.html
See also the CS51 Resources web page for OCaml books, references, and tutorials.

Coq resources
Download Coq.
Coq includes an IDE, CoqIDE. Alternatively, with Emacs, you can use Proof General.
Coq documentation.
Dafny resources
Dafny on Github.
Dafny on rise4fun.
Dafny in Visual Studio Code.
Haskell resources
Download The Haskell Platform.
List of Haskell tutorials. If you want to get more meta, see How to Learn Haskell.
haskell.org contains lots of reference information, language specification, etc.



Gödel's incompleteness theorems are two theorems of mathematical logic that demonstrate the inherent limitations of every formal axiomatic system capable of modelling basic arithmetic. These results, published by Kurt Gödel in 1931, are important both in mathematical logic and in the philosophy of mathematics. The theorems are widely, but not universally, interpreted as showing that Hilbert's program to find a complete and consistent set of axioms for all mathematics is impossible.



<select name="textbook">
SELECT textbook </option>

Aho, Sethi, Ullman - Compilers</option>
Brookshear - Computer Science - An Overview </option>
Brookshear - Theory of Computation </option>
Cohen - Intro to Computer Theory </option>
Davis - Computability, Complexity, and Languages </option>
Du and Ko - Problem Solving in Automata, Languages and Complexity </option>
Floyd and Beigel - The Language of Machines</option>
Gersting - Mathematical Structures for Computer Science</option>
Goddard - Introducing the Theory of Computation </option>
Homer - Computability and Complexity Theory </option>
Johnsonbaugh - Discrete Mathematics </option>
Kelley - Automata and Formal Languages </option>
Kinber and Smith - Theory of Computing</option>
Kozen - Automata and Computability </option>
Lewis and Papadimitriou - Elements of the Theory of Computation </option>
Linz - Formal Languages and Automata</option>
Martin - Introduction to Languages and the Theory of Computation</option>
Motwani, Ullman and Hopcroft - Intro to Automata Theory, Languages
and Computation </option>
Sipser - Introduction to the Theory of Computation
Sudkamp - Languages and Machines
Taylor - Models of Computation and Formal Languages
OTHER 



可计算的route
david hilbert 提出   数学系统公理化完整性
Kurt Gödel 证明无法完整性。 
alonzo church 和 alan turing 也证明形式系统不完整。 


数学的不确定性

构造一个形式系统， 让形式系统出现自证的悖论
同构的威力

galois theory


分点突破


galois theory的一点点思考：
根的对称性
群的对称性
分裂域 与  galois group 的对称性

大于5次  一点关系没有办法满足。 




lagrange root permutation
the roots of early group theory in the works of lagrange. 



The symmetric polynomials
Albert Girard (1590-1633), a flemish mathematician, published in 1629, in Amsterdam, a book called Invention nouvelle en l'algèbre, in which clear relations between roots and coefficients of polynomials were stated for the first time.



Edward Waring (1734-1793), an English mathematician, searched for the correlations between the degrees of the resolvent polynomials of a polynomial


The work of Lagrange
Joseph Louis Lagrange (1736-1813), a French mathematician, proved that a polynomial equation can be solved by radicals if a particularly related equation called the Lagrange resultant has degree less than the degree of the original equation. The proof involved a concept that later was to become fundamental to the theory of polynomial equations: that of the permutation of the roots. The Lagrange resultant is a polynomial constructed by means of a rational function of all possible permutations of the roots. An important characteristic of the theorem is that it is an existence theorem, as opposed to the previous methods that had all been concerned with the construction of a solving formula. Using this result, Ruffini produced in 1799 an erroneous proof that a polynomial equation od degree greater than 4 was not soluble by radicals. Abel independently found in 1824 a correct proof of the same theorem; thus the question of solving polynomial equation was in part settled. Still there are polynomials of degree greater than 4 that are clearly soluble, like tex2html_wrap_inline304. What remained to be done was to find a method to determine exactly which polynomial is soluble.


The work of Vandermonde and Gauss
Vandermonde proposed in 1770 that the key to solving a general polynomial equation
displaymath306
was represented by the roots of the equation tex2html_wrap_inline308. Gauss has the undoubted credit for having laid the first stone in the path that Galois successively followed. He showed that the roots of the polynomial equation tex2html_wrap_inline310 where p is prime are rational functions of the roots of a sequence of equations tex2html_wrap_inline314 where the coefficients of tex2html_wrap_inline316 are rational expressions of the roots of tex2html_wrap_inline318 and the degrees of the polynomials in the sequence are the all the prime numbers in the factorization of p-1.


It is not surprising that Galois was not understood even by the greatest mathematicians of the time. His papers make such a large number of unproved (though true) assumptions, that at first they really are incomprehensible. Modern Galois theory can be viewed from two possible angles, which are however closely linked: group theory and field theory. Following the group-theoretic approach, to each polynomial there corresponds a group of permutations of the roots; if the group contains a series of certain particular nested subgroups such that the intersection of the series is the identity element, this means that the identity is the only permutation of the roots that leave all the known rational relations between the roots valid, and hence it is possible to determine them. If the intersection contains other permutations apart from the identity, it means that all the known relations cannot determine the roots because even if we permute them with the permutations in the intersection the relations still hold. Taking the field-theoretic approach, for any polynomial having roots tex2html_wrap_inline322 and coefficients in the field F there exists a field F' such that the polynomial is reducible into linear factors in F'. Obviously any field tex2html_wrap_inline330 is such that the polynomial splits into linear factors. Any such field G is called a splitting field for f(x). It is clear that for any polynomial f(x) over F with roots tex2html_wrap_inline322 the field tex2html_wrap_inline342 is a splitting field for f. Very simply put, if F' is expressible by adjoining a finite number of radicals of the form tex2html_wrap_inline348 to the base field F, then it is possible to express the roots tex2html_wrap_inline322 in terms of the radical operations tex2html_wrap_inline354 and hence there is a radical formula to find the roots in terms of the coefficients. Thus Galois found necessary and sufficient conditions for the roots to be expressed as rational functions of the coefficients, settling the problem definitively.





-----some book---
Inside the Machine: An Illustrated Introduction to Microprocessors and Computer Architecture
Structure and Interpretation of Computer Programs
Design Patterns: Elements of Reusable Object-Oriented Software
Code: The Hidden Language of Computer Hardware and Software
Cracking the Coding Interview: 189 Programming Questions and Solutions
Code Complete: A Practical Handbook of Software Construction
Programming Pearls
The Pragmatic Programmer: Your Journey to Mastery
Code Simplicity: The Fundamentals of Software
Algorithms to Live By: The Computer Science of Human Decisions
Clean Code: A Handbook of Agile Software Craftsmanship
Think Like a Programmer: An Introduction to Creative Problem Solving
Introduction to Algorithms
Peopleware: Productive Projects and Teams
Soft Skills: The software developer’s life manual&nbsp;
Rapid Development: Taming Wild Software Schedules
Coders at Work: Reflections on the Craft of Programming
Don’t Make Me Think, Revisited: A Common Sense Approach to Web Usability
The Passionate Programmer: Creating a Remarkable Career in Software Development
Working Effectively with Legacy Code
The Self-Taught Programmer: The Definitive Guide to Programming Professionally
The Mythical Man-Month: Essays on Software Engineering
Refactoring: Improving the Design of Existing Code
HTML and CSS: Design and Build Websites
Learning Web Design: A Beginner’s Guide to HTML, CSS, JavaScript, and Web Graphics
Eloquent JavaScript: A Modern Introduction to Programming
You Don’t Know JS Yet: Get Started
Effective Java
Head First Java
Java Concurrency in Practice
Modern PHP
Head First PHP &amp; MySQL: A Brain-Friendly Guide
Eloquent Ruby
The Well-Grounded Rubyist
Python Crash Course: A Hands-On, Project-Based Introduction to Programming
Head First Python: A Brain-Friendly Guide
Learn Python 3 the Hard Way: A Very Simple Introduction to the Terrifyingly Beautiful World of Computers and Code
C# in Depth
C# 7.0 in a Nutshell: The Definitive Reference
C Programming Language
Practical C Programming: Why Does 2+2 = 5986?
Objective-C Programming: The Big Nerd Ranch Guide
Effective Objective-C 2.0: 52 Specific Ways to Improve Your IOS and OS X Programs
C++ Primer
Programming: Principles and Practice Using C++
Learning R: A Step-by-Step Function Guide to Data Analysis
R Cookbook: Proven Recipes for Data Analysis, Statistics, and Graphics
The Art of R Programming: A Tour of Statistical Software Design
SQL in 10 Minutes, Sams Teach Yourself
SQL Queries for Mere Mortals: A Hands-On Guide to Data Manipulation in SQL
Android Application Development All-in-One For Dummies
Head First Android Development: A Brain-Friendly Guide
iOS Programming: The Big Nerd Ranch Guide
Swift Programming: The Big Nerd Ranch Guide


--------


被识别叫作语言


A language is called a regular language if some finite automaton recognizes it.


regular operations union, concatenation, and star


nondeterministic finite automaton

EQUIVALENCE OF NFAS AND DFAS
1. 因为NFA会出现一个输入产生两个， 三个， 或多个状态的现象。 
2. 对状态做对自身的笛卡尔积，直到包含了所有状态，  然后重新绘制。 



 language is regular if and only if some nondeterministic finite automaton recognizes it


theorem 1:
 the class of regular languages is closed under the union operation.
构造一个NFA， 空指向两个子NFA。 证毕。

theorem 2:
The class of regular languages is closed under the concatenation operation.
同上， 构造NFA。 一个NFA 空连接另一个  NFA。


the class of regular languages is closed under the star operation.

在accept 状态用空连接 start 状态。 


A language is regular if and only if some regular expression describes it.


NONREGULAR LANGUAGES
找到违反他特征的例子。 

正则的特性
THE PUMPING LEMMA FOR REGULAR LANGUAGES
大于等于三的 string 中间存在可重复。 


---------

 context-free grammars::: recursive structure


pushdown automata, a class of machines recognizing the context-free languages

parse tree.


Any language that can be generated by some context-free grammar is called a context-free language(CFL).



fmcoirst, many CFLs are the union of simpler CFLs. If you must construct a CFG for
a CFL that you can break into simpler pieces, do so and then construct individual
grammars for each piece. These individual grammars can be easily merged into
a grammar for the original language by combining their rules and then adding
the new rule S → S1 | S2 | ··· | Sk, where the variables Si are the start variables
for the individual grammars. Solving several simpler problems is often easier
than solving one complicated problem.


computational model called pushdown automata.

finite automata 
为什么加stack, 可能就是为了方便识别递归。 
 context-free grammars and pushdown automata are
equivalent in power. Both are capable of describing the class of context-free languages. We show how to convert any context-free grammar into a pushdown automaton that recognizes the same language and vice versa. 


cfg to pda
stack 实现识别递归
: 递归的特征

(
 Theorem: If G is a CFG for a language L, 
then there exists a PDA for L as well.
● Idea: Build a PDA that simulates 
expanding out the CFG from the start 
symbol to some particular string.
● Stack holds the part of the string we 
haven't matched yet.)

THE PUMPING LEMMA FOR CONTEXT-FREE LANGUAGES
分成5部分。 
. It states that every context-free language has a special value called the pumping length such that all longer strings in the language can be “pumped.” This time the meaning of pumped is a bit more complex. It means that the string can be divided into five parts so that the second and the fourth parts may be repeated together any number of times and the resulting string still remains in the language.

找一个不是递归关系的。 

a(↑n)b(↑n)c(↑n)   他就不在



The languages that are recognizable by deterministic pushdown automata (DPDAs) are called deterministic context-free languages (DCFLs). 
This subclass of the context-free languages is relevant to practical applications, such as the design of parsers in compilers for programming languages, because the parsing problem is generally easier for DCFLs than for CFLs. This section gives a short overview of this important and beautiful subject.


 In a PDA, if there are multiple 
nondeterministic choices, you cannot
treat the machine as being in multiple 
states at once.
● Each state might have its own stack 
associated with it.
● Instead, there are multiple parallel 
copies of the machine running at once, 
each of which has its own stack



图灵机 与 lambda 演算的对等关系。 
图灵机 类似模拟 递归。 
turing machine lambda calculus equivalence

机算机核心问题
David Hilbert’s Entscheidungsproblem


The class of DCFLs is closed under complementation.
PROOF IDEA Swapping the accept and non-accept states of a DFA yields a new DFA that recognizes the complementary language, thereby proving that the class of regular languages is closed under complementation. 


加endmarked string也可被识别。 
A is a DCFL if and only if A⊣ is a DCFL.

DCFG
A deterministic context-free grammar is a context-free grammar such that every valid string has a forced handle.


单带 多带 TM。 
单带增加空间复杂度。 

o construct DFA DK, we’ll construct an equivalent NFA K and convert K to
DK1 via the subset construction introduced in Theorem 1.39.


对等关系  映射怎么找。 同构
every DCFG has an equivalent DPDA.

In the 1960s, theoretical research in computer science on regular expressions and finite automata led to the discovery that context-free grammars are equivalent to nondeterministic pushdown automata.[1][2][3] These grammars were thought to capture the syntax of computer programming languages. The first computer programming languages were under development at the time (see History of programming languages) and writing compilers was difficult. But using context-free grammars to help automate the parsing part of the compiler simplified the task. 



an LR(k) grammar is a context-free grammar such that the handle of every valid string is forced by lookahead k.



图灵机识别  011000#011000
Turing machine M1 computing on input 011000#011000

图灵机定义
 δ : Q × Γ−→Q × Γ × {L, R} is the transition function,

 Σ ⊆ Γ,


 表示法

  a Turing machine computes, changes occur in the current state, the current tape contents, and the current head location. A setting of these three items is called a configuration of the Turing machine. Configurations often are represented in a special way. For a state q and two strings u and v over the tape alphabet Γ, we write uqv for the configuration where the current state is q, the current tape contents is uv, and the current head location is the first symbol of v. The tape contains only blanks following the last symbol of v. For example,
1011q701111 represents the configuration when the tape is 101101111, the current state is q7, and the head is currently on the second 0. Figure 3.4 depicts a Turing machine with that configuration.


call a language Turing-recognizable if some Turing machine
recognizes it.1


call a language Turing-decidable or simply decidable if some
Turing machine decides it



every multitape Turing machine has an equivalent single-tape Turing machine



计算机发展史
John Mauchly
Oral history interview with J. Presper Eckert at Charles Babbage Institute, University of Minnesota, Minneapolis. Eckert, a co-inventor of the ENIAC, discusses its development at the University of Pennsylvania and the interaction of the personnel at the Moore School.
John W. Mauchly and the Development of the ENIAC Computer - by Asaf Goldschmidt and Atsushi Akera, An Exhibition in the Department of Special Collections Van Pelt Library, University of Pennsylvania
Mauchly: The Computer and the Skateboard. The only work to contain archival footage of John Mauchly speaking about the development of the ENIAC.
O'Connor, John J.; Robertson, Edmund F., "John Mauchly", MacTutor History of Mathematics archive, University of St Andrews.


, we prove one of the most philosophically important theorems of the theory of computation: There is a specific problem that is algorithmically unsolvable. Computers appear to be so powerful that you may believe that all problems will eventually yield to them. 


方法树， 在宽度上一个接收就接收。 都是拒绝的时候拒绝。 

TM：
识别器， 判定器， 转换器， 产生器， 枚举器。 


可识别等价可枚举。 
A language is Turing-recognizable if and only if some enumerator enumerates it. 


形式系统要么是不完备(complete)  要么不相容的（closure） 
不完备，


举一个复杂点的例子，也就是这一节最开头的那个表达式：

(5 - 3) * (4 + (2 * 3 - 5) * 6)
它可以被转化为一串语句：

{
    a = 2 * 3
    b = a - 5
    c = b * 6
    d = 4 + c
    e = 5 - 3
    e * d
}

王垠思想：
总有人提出一套套的所谓“方法论”或者“原则”，比如 Extreme Programming，Design Patterns，Agile，Pair Programming，Test Driven Development（TDD），DRY principle…… 他们把这些所谓方法论兜售给各个软件公司，鼓吹它们的各种好处，说使用这些方法，就可以用一些平庸的“软件工程师”，制造出高质量低成本的软件。这就跟减肥药的广告一样：不用运动，不用节食，一个星期瘦 20 斤。

你开头还不以为然，觉得这些肤浅的说法能造成什么影响。结果久而久之，这些所谓“方法论”和“原则”成为了整个行业的教条，造成了文化大革命一样的风气。违反这些教条的人，必然被当成菜鸟一样鄙视，当成小学生一样教育，当成反革命一样批斗。就算你技术比这些教条的提出者高不知道多少倍，也无济于事，因为他们已经靠着一张嘴占据了自己的地位。



可世界上就是有这样划算的行当，虽然写不出好的代码，对计算的理解非常肤浅，却可以通过嘴里说说，得到评价别人“代码质量”的权力，占据软件公司的管理层位置。久而久之，别人还以为他们是什么泰斗。你仔细看过提出 Design Pattern 的“四人帮”（GoF），做出过什么有实质价值的东西吗？提出“DRY Principle”的作者，做出过什么吗？再看看 Agile，Pair Programming，TDD 的提出者？他们其实不懂很多编程，写出文章和书来也是极其肤浅。

所谓“软件工程”，并不像土木工程，机械工程，电机工程，是建立在实际的，科学的基础上的。跟这些“硬工程”不一样，软件弄得不好不会出人命，也不会像芯片公司那样，出一个 bug 立即导致几十上百亿的损失。




想起这些借口我就想起一个笑话：两夫妻发现床上有跳蚤，身上被咬了好多包。去买了号称“杀伤率 100 %”的跳蚤药，撒了好多在床上。第二天早上起来，发现仍然被咬了好多新的包。妻子责怪丈夫，说他没看说明书就乱撒。结果丈夫打开说明书一看，内容如下：

本跳蚤药使用方法：

抓住跳蚤
掰开跳蚤的嘴
把药塞进跳蚤嘴里
合上跳蚤的嘴
我发现很多软件工程的所谓方法论失败之后的借口，跟这跳蚤药的说明书很像。





课程大纲
根据第二期课程的经验，我想对课程的内容做一个比以前详细的说明。之前一直对课程内容没有很多说明，一方面为的是留下自由发挥的空间，一方面是为了让学生有一定的神秘感，引发好奇心。但这么简单的说明似乎会让不知情的人误以为“已经学过这些东西”，有时候会发现一些人看了说明之后，自以为我教的内容他都会了。我只为他们感到可惜。

下面简要说一下课程的内容：

教学语言。课程目前使用 JavaScript 作为教学语言，但并不是教 JavaScript 语言本身，不会使用 JavaScript 特有的任何功能。课程教的思想不依赖于 JavaScript 的任何特性，它可以应用于任何语言，课程可以在任何时候换成任何语言。学生从零开始，学会的是计算机科学最核心的思想，从无到有创造出各种重要的概念，直到最后实现出自己的编程语言和类型系统。

课程强度。课程的设计是一个逐渐加大难度，比较辛苦，却很安全的山路，它通往很高的山峰。要参加课程，请做好付出努力的准备。在两个月的时间里，你每天需要至少一个小时来做练习，有的练习需要好几个小时才能做对。跟其他的计算机教学不同，学生不会因为缺少基础而放弃，不会误入歧途，也不会掉进陷阱出不来。学生需要付出很多的时间和努力，但没有努力是白费的。

曾经有一两个学生因为低估了学习的强度，同时又有其他重要任务，结果发现忙不过来，所以请合理的安排，不要在有其他重要任务的同时参加学习。

第一课：函数。跟一般课程不同，我不从所谓“Hello World”程序开始，也不会叫学生做一些好像有趣而其实无聊的小游戏。一开头我就讲最核心的内容：函数。关于函数只有很少几个知识点，但它们却是一切的核心。只知道很少的知识点的时候，对它们进行反复的练习，让头脑能够自如地对它们进行思考和变换，这是教学的要点。我为每个知识点设计了恰当的练习。

第一课的练习每个都很小，只需要一两行代码，却蕴含了深刻的原理。练习逐渐加大难度，直至超过博士课程的水平。我把术语都改头换面，要求学生不上网搜索相关内容，为的是他们的思维不受任何已有信息的干扰，独立做出这些练习。练习自成系统，一环扣一环。后面的练习需要从前面的练习获得的灵感，却不需要其它基础。有趣的是，经过正确的引导，好些学生把最难的练习都做出来了，完全零基础的学生也能做出绝大部分，这是我在世界名校的学生里都没有看到过的。具体的内容因为不剧透的原因，我就不继续说了。

第二课：递归。递归可以说是计算机科学（或数学）最重要的概念。我从最简单的递归函数开始，引导理解递归的本质，掌握对递归进行系统化思考的思路。递归是一个很多人自以为理解了的概念，而其实很多人都被错误的教学方式误导了。很多人提到递归，只能想起“汉诺塔”或者“八皇后”问题，却不能拿来解决实际问题。很多编程书籍片面强调递归的“缺点”，教学生如何“消除递归”，却看不到问题的真正所在——某些语言（比如 C 语言）早期的函数调用实现是错误而效率低下的，以至于学生被教导要避免递归。由于对于递归从来没有掌握清晰的思路，在将来的工作中一旦遇到复杂点的递归函数就觉得深不可测。

第三课：链表。从零开始，学生不依赖于任何语言的特性，实现最基本的数据结构。第一个数据结构就是链表，学生会在练习中实现许多操作链表的函数。这些函数经过了精心挑选安排，很多是函数式编程语言的基本函数，但通过独立把它们写出来，学生掌握的是递归的系统化思路。这使得他们能自如地对这类数据结构进行思考，解决新的递归问题。

与一般的数据结构课程不同，这个课程实现的大部分都是「函数式数据结构」，它们具有一些特别的，有用的性质。因为它们逻辑结构清晰，比起普通数据结构书籍会更容易理解。与 Haskell 社区的教学方式不同，我不会宗教式的强调纯函数的优点，而是客观地让学生领会到其中的优点，并且发现它们的弱点。学会了这些结构，在将来也容易推广到非函数式的结构，把两种看似不同的风格有机地结合在一起。

第四课：树结构。从链表逐渐推广出更复杂的数据结构——树。在后来的内容中，会常常用到这种结构。树可能是计算机科学中最常用，最重要的数据结构了，所以理解树的各种操作是很重要的。我们的树也都是纯函数式的。

第五课：计算器。在熟悉了树的基本操作之后，实现一个比较高级的计算器，它可以计算任意嵌套的算术表达式。算术表达式是一种“语法树”，从这个练习学生会理解“表达式是一棵树”这样的原理。

第六课：查找结构。理解如何实现 key-value 查找结构，并且亲手实现两种重要的查找数据结构。我们的查找结构也都是函数式数据结构。这些结构会在后来的解释器里派上大的用场，对它们的理解会巩固加深。

第七课：解释器。利用之前打好的基础，亲手实现计算机科学中最重要，也是通常认为最难理解的概念——解释器。解释器是理解各种计算机科学概念的关键，比如编程语言，操作系统，数据库，网络协议，Web 框架。计算机最核心的部件 CPU 其实就是一个解释器，所以解释器的认识能帮助你理解「计算机体系构架」，也就是计算机的“硬件”。你会发现这种硬件其实和软件差别不是很大。你可以认为解释器就是「计算」本身，所以它非常值得研究。对解释器的深入理解，也能帮助理解很多其它学科，比如自然语言，逻辑学。

第八课：类型系统。在解释器的基础上，学生会理解并实现一个相当高级的类型系统（type system）和类型检查器（typechecker）。这相当于实现一个类似 Java 的静态类型语言，但比 Java 在某些方面还要高级和灵活。我们的类型系统包含了对于类型最关键的要素，而不只是照本宣科地讲解某一种类型系统。当你对现有的语言里的类型系统不满意的时候，这些思路可以帮助你设计出自己的类型系统。学生会用动手的方式去理解静态类型系统的原理，其中的规则，却不含有任何公式。

类型系统的规则和实现，一般只会在博士级别的研究中才会出现，可以写成一本厚书（比如 TAPL 那样的），其中有各种神秘的逻辑公式。而我的学生从零开始，一节课就可以掌握这门技术的关键部分，实现出正确的类型系统，并且推导出正确的公式。有些类型规则是如此的微妙，以至于微软这么大的公司在 21 世纪做一个新的语言（TypeScript)，仍然会在初期犯下类型专家们早已熟知的基本错误。上过这个课程的很多同学，可以说对这些基础原理的理解已经超过了 TypeScript 的设计者，但由于接受的方式如此自然，他们有一些人还没有意识到自己的强大。

关于面向对象。虽然课程不会专门讲“面向对象”的思想，但面向对象思想的本质（去掉糟粕）会从一开头就融入到练习里。上过课的同学到后来发现，虽然我从来没直接教过面向对象，而其实他们已经理解了面向对象的本质是什么。在将来的实践中，他们可以用这个思路去看破面向对象思想的本质，并且合理地应用它。

奖励练习。途中我会通过“奖励练习”的方式补充其它内容。比如第二期的课程途中，我临时设计了一个 parser 的练习，做完了其它练习的同学通过这个练习，理解了 parser 的原理，写出了一个简单但逻辑严密的 parser。奖励练习之所以叫“奖励”，因为并不是所有学生都能得到这个练习，只有那些付出了努力，在其他练习中做到融会贯通，学有余力的学生才会给这个练习。这样会鼓励学生更加努力地学习。

如果理解了以上内容蕴含了什么，你可能就不会再问“这些我都学过了，我可不可以参加高级班”了，因为极少有人真的理解了以上内容。就算世界上最高级职位的一些程序员，大学里的教授，对于这些也有很多含糊不清的地方。我自己也通过讲授这些内容得到了启发。

一个朋友看了我的课程内容说，这不叫“基础班”，只能叫“大师班”。他不相信零基础的学生能跟上，但事实却是可行的。为什么不能即是“基础班”又是“大师班”呢？有句话说得好，大师只不过是把基础的东西理解得很透彻的人而已。我希望这个基础班能帮助人们获得本质的原理，帮助他们看透很多其它内容。所以上了“基础班”，可能在很长时间之内都不需要“高级班”了，因为他们已经获得了很强的自学能力，能够自己去探索未知的世界，攀登更高的山峰。



洪水算法
从源头一步一步向相邻点蔓延


-------------------------------------

通用图灵机可识别， 就是做同构。 
北京大学_刘田

可判定即可停机， 不会出现死循环是可计算

算法主要是学习那些东西是不可被计算的。 
可计算理论都是研究的不可计算的问题。 



正则（fa）的可计算问题:
	图灵机 可判定  正则。 
	nfa自动机是可计算的。 是可判定的。 在图灵模型上。 
	E(dfa)不接受任何串的dfa是可判定的。 
	把他转化成图的问题。 


	判定两个有穷自动机是否相等。 是可判定的。
	正则语言对称差运算是封闭的。 

上下文无关语言的可计算问题。 
	cfg的派生问题。是否可派生一个字串w， 证明方法， 变成Chomsky 范式， 因为n长度的Chomsky 范式是2n-1步，遍历所有2n-1的派生。 
	cfg 的空性问题。检查初始变原是否能产生一个终结符。 反向推导， 看终结符是否可以到原始变原。 
	给定两个cfg判定是否产生同一个语言。 （不可判定）
	每个cfl是可判定的。 


可判定即可停机， 不会出现死循环是可计算

图灵机的可计算问题
	图灵机模拟形式系统， 对等 lambda calculus. 
	检查一个图灵机是否接受一个串，（是不可判定的），反证法。 构造悖论。 如果证明机返回接受我拒绝， 如果证明机返回拒绝我接受。 
	看证明机， 能不能判定我是否接受一个w。 证明没有这样的证明机。 


可识别只能证明是这个东西， 不能证明不是这个东西。 可判定是可识别的特例。 

A和A的初都是可识别的， 那么他们是可判定的。 
图灵机的补不是图灵机可识别的。 存在非图灵可识别语言。 

语言类之间的关系

正则语言  上下文无关  图灵可判定语言  图灵可识别语言（递归可枚举）
  非图灵语言

	是不是可停机是不可判定。 

	图灵机的空性问题。 也是不可判定的。 构造一个图灵机只识别w。 则图灵机可判定w， 反证。 

检查一个图灵机是否有一个正则自动机？是不可判定的。 

线性界限自动机  是可判定的。 
E LBA是不可判定的。 

波斯特对应问题
归约  
可判定语言类在归约下是封闭的。 


rice定理。 
指标集是不可判定的。 


DTM决定性图灵机运行时间由输入长度来确定。 

log  幂函数的  反面。 
In mathematics, the logarithm is the inverse function to exponentiation. 
e (mathematical constant)

Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. Big O is a member of a family of notations invented by Paul Bachmann,[1] Edmund Landau,[2] and others, collectively called Bachmann–Landau notation or asymptotic notation.

In computer science, big O notation is used to classify algorithms according to how their run time or space requirements grow as the input size grows

https://en.wikipedia.org/wiki/Big_O_notation


输入长度与编码有关
输入规模  与  问题中的自然参数有关。 与编码无关。 



“P vs NP” 这个问题有它的理论价值，它是有趣的问题，里面的有些思路有启发意义，值得花些时间来了解。但计算机科学界长久以来都严重夸大它的重要性，把一个很普通的问题捧上了天，吹得神乎其神。

再加上图灵机模型在计算理论界的广泛使用，使得这门学问显得异常艰深。很多人看到图灵机就晕了，在课程上蒙混过关，考试完了就全忘了，根本无法理解里面的实质内容。正是因为很多人的不明觉厉，使得“P vs NP”登上了它在 CS 界的宝座。


“无穷”对于现实的问题是没有意义的。


微积分的重要性就是摒弃了无限这虚无飘渺的东西。 
计算复杂性概念

多带单带  单带空间上的限制带来复杂性。 
多带变单带：时间平方。 
非确定性与确定性图灵： 指数 。 


复杂性分类： 
P类 polynomial time
有向图可达性
	蛮力搜索。 
	宽度优先搜索。 
判断互素：
	蛮力法
	辗转相除法

识别是不是ｃｆｌ：
	蛮力法：
	动态规划：

NP类："nondeterministic polynomial time"
	哈密顿路径（送快递）：过每个点一次，且恰好一次。 
	每次问有没有， 有删边。 搜索归为判定问题。 
	验证机：

语言有多项式时间验证机， 就是NP类
	非确定图灵可判定语言。 
	团问题
	子集和问题（背包问题）

coNP类（补NP）  EXP类（指数类）


P成员资格可以快速判定的语言类
NP成员资格可以快速验证的语言类



空间复杂性 （space complex）
空间复杂性 与  时间复杂性。 

萨维奇定理
用确定性空间来模拟非确定型空间只有平方的增长。 
pspace类


亚线性空间比p还小（L类， NL 类）sub-linear
设多带  一条只读带， 一条可读写带， 一条输出带

NSPACE = CONSPACE


空间可构造

apt install clisp
clisp

  i i i i i i i       ooooo    o        ooooooo   ooooo   ooooo
  I I I I I I I      8     8   8           8     8     o  8    8
  I  \ `+' /  I      8         8           8     8        8    8
   \  `-+-'  /       8         8           8      ooooo   8oooo
    `-__|__-'        8         8           8           8  8
        |            8     o   8           8     o     8  8
  ------+------       ooooo    8oooooo  ooo8ooo   ooooo   8

Welcome to GNU CLISP 2.49.92 (2018-02-18) <http://clisp.org/>

Copyright (c) Bruno Haible, Michael Stoll 1992-1993
Copyright (c) Bruno Haible, Marcus Daniels 1994-1997
Copyright (c) Bruno Haible, Pierpaolo Bernardi, Sam Steingold 1998
Copyright (c) Bruno Haible, Sam Steingold 1999-2000
Copyright (c) Sam Steingold, Bruno Haible 2001-2018

Type :h and hit Enter for context help.

[1]> (+ 3 4)
7
[2]> (+ 3 4 8)
15




