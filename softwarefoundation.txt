https://www.seas.harvard.edu/courses/cs152/2021sp/resources.html
The Curry-Howard Isomorphism
Resources
Text books
A number of excellent books and on-line resources overlap with the course's content and can provide alternate explanations despite differences in notation and approach. Let the instructor know if you have trouble finding the intersection between these resources and the course content.

"Types and Programming Languages" by Benjamin C. Pierce, MIT Press, 2002.
Available on reserve at the library.
"Software Foundations" by Benjamin C. Pierce et al., Volume 1: Logical Foundations and Volume 2: Programming Language Foundations.
Available as literate Coq files.
Also available as literate Agda files thanks to Philip Wadler, Wen Kokke and Jeremy Siek.
"Practical Foundations for Programming Languages" by Robert Harper, Cambridge University Press, 2013.
Draft available on Harper's website.
"Concepts in Programming Languages" by John C. Mitchell, Cambridge University Press, 2003.
Available online through Harvard University Libraries eContent Collection.
"The Formal Semantics of Programming Languages" by Glynn Winskel, MIT Press, 1993.
Available on reserve at the library.
"Programming Languages: Application and Interpretation" by Shriram Krishnamurthi.
There are two editions, both available on the author's website: http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/.
OCaml resources
Installation: https://ocaml.org/docs/install.html
Tools: https://github.com/realworldocaml/book/wiki/Installation-Instructions
This link gives instructions for installing things like Tuareg (a useful emacs mode) and Merlin (advanced IDE features).

Installing Tuareg is pretty simple and will make your OCaml coding experience a lot nicer (though it's of course not necessary). Merlin is probably overkill unless you know what you're doing.

Learning:
Standard library documentation: http://caml.inria.fr/pub/docs/manual-ocaml/libref/index.html
The following documentation may be particularly useful as you work on your assignments.
Sets: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.Make.html
Maps: http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.Make.html
Everything you need to know and more: http://caml.inria.fr/pub/docs/manual-ocaml/index.html
Code examples: http://ocaml.org/learn/tutorials/99problems.html
See also the CS51 Resources web page for OCaml books, references, and tutorials.

Coq resources
Download Coq.
Coq includes an IDE, CoqIDE. Alternatively, with Emacs, you can use Proof General.
Coq documentation.
Dafny resources
Dafny on Github.
Dafny on rise4fun.
Dafny in Visual Studio Code.
Haskell resources
Download The Haskell Platform.
List of Haskell tutorials. If you want to get more meta, see How to Learn Haskell.
haskell.org contains lots of reference information, language specification, etc.



Gödel's incompleteness theorems are two theorems of mathematical logic that demonstrate the inherent limitations of every formal axiomatic system capable of modelling basic arithmetic. These results, published by Kurt Gödel in 1931, are important both in mathematical logic and in the philosophy of mathematics. The theorems are widely, but not universally, interpreted as showing that Hilbert's program to find a complete and consistent set of axioms for all mathematics is impossible.



<select name="textbook">
SELECT textbook </option>

Aho, Sethi, Ullman - Compilers</option>
Brookshear - Computer Science - An Overview </option>
Brookshear - Theory of Computation </option>
Cohen - Intro to Computer Theory </option>
Davis - Computability, Complexity, and Languages </option>
Du and Ko - Problem Solving in Automata, Languages and Complexity </option>
Floyd and Beigel - The Language of Machines</option>
Gersting - Mathematical Structures for Computer Science</option>
Goddard - Introducing the Theory of Computation </option>
Homer - Computability and Complexity Theory </option>
Johnsonbaugh - Discrete Mathematics </option>
Kelley - Automata and Formal Languages </option>
Kinber and Smith - Theory of Computing</option>
Kozen - Automata and Computability </option>
Lewis and Papadimitriou - Elements of the Theory of Computation </option>
Linz - Formal Languages and Automata</option>
Martin - Introduction to Languages and the Theory of Computation</option>
Motwani, Ullman and Hopcroft - Intro to Automata Theory, Languages
and Computation </option>
Sipser - Introduction to the Theory of Computation
Sudkamp - Languages and Machines
Taylor - Models of Computation and Formal Languages
OTHER 



可计算的route
david hilbert 提出   数学系统公理化完整性
Kurt Gödel 证明无法完整性。 
alonzo church 和 alan turing 也证明形式系统不完整。 


数学的不确定性

构造一个形式系统， 让形式系统出现自证的悖论
同构的威力

galois theory


分点突破


galois theory的一点点思考：
根的对称性
群的对称性
分裂域 与  galois group 的对称性

大于5次  一点关系没有办法满足。 




lagrange root permutation
the roots of early group theory in the works of lagrange. 



The symmetric polynomials
Albert Girard (1590-1633), a flemish mathematician, published in 1629, in Amsterdam, a book called Invention nouvelle en l'algèbre, in which clear relations between roots and coefficients of polynomials were stated for the first time.



Edward Waring (1734-1793), an English mathematician, searched for the correlations between the degrees of the resolvent polynomials of a polynomial


The work of Lagrange
Joseph Louis Lagrange (1736-1813), a French mathematician, proved that a polynomial equation can be solved by radicals if a particularly related equation called the Lagrange resultant has degree less than the degree of the original equation. The proof involved a concept that later was to become fundamental to the theory of polynomial equations: that of the permutation of the roots. The Lagrange resultant is a polynomial constructed by means of a rational function of all possible permutations of the roots. An important characteristic of the theorem is that it is an existence theorem, as opposed to the previous methods that had all been concerned with the construction of a solving formula. Using this result, Ruffini produced in 1799 an erroneous proof that a polynomial equation od degree greater than 4 was not soluble by radicals. Abel independently found in 1824 a correct proof of the same theorem; thus the question of solving polynomial equation was in part settled. Still there are polynomials of degree greater than 4 that are clearly soluble, like tex2html_wrap_inline304. What remained to be done was to find a method to determine exactly which polynomial is soluble.


The work of Vandermonde and Gauss
Vandermonde proposed in 1770 that the key to solving a general polynomial equation
displaymath306
was represented by the roots of the equation tex2html_wrap_inline308. Gauss has the undoubted credit for having laid the first stone in the path that Galois successively followed. He showed that the roots of the polynomial equation tex2html_wrap_inline310 where p is prime are rational functions of the roots of a sequence of equations tex2html_wrap_inline314 where the coefficients of tex2html_wrap_inline316 are rational expressions of the roots of tex2html_wrap_inline318 and the degrees of the polynomials in the sequence are the all the prime numbers in the factorization of p-1.


It is not surprising that Galois was not understood even by the greatest mathematicians of the time. His papers make such a large number of unproved (though true) assumptions, that at first they really are incomprehensible. Modern Galois theory can be viewed from two possible angles, which are however closely linked: group theory and field theory. Following the group-theoretic approach, to each polynomial there corresponds a group of permutations of the roots; if the group contains a series of certain particular nested subgroups such that the intersection of the series is the identity element, this means that the identity is the only permutation of the roots that leave all the known rational relations between the roots valid, and hence it is possible to determine them. If the intersection contains other permutations apart from the identity, it means that all the known relations cannot determine the roots because even if we permute them with the permutations in the intersection the relations still hold. Taking the field-theoretic approach, for any polynomial having roots tex2html_wrap_inline322 and coefficients in the field F there exists a field F' such that the polynomial is reducible into linear factors in F'. Obviously any field tex2html_wrap_inline330 is such that the polynomial splits into linear factors. Any such field G is called a splitting field for f(x). It is clear that for any polynomial f(x) over F with roots tex2html_wrap_inline322 the field tex2html_wrap_inline342 is a splitting field for f. Very simply put, if F' is expressible by adjoining a finite number of radicals of the form tex2html_wrap_inline348 to the base field F, then it is possible to express the roots tex2html_wrap_inline322 in terms of the radical operations tex2html_wrap_inline354 and hence there is a radical formula to find the roots in terms of the coefficients. Thus Galois found necessary and sufficient conditions for the roots to be expressed as rational functions of the coefficients, settling the problem definitively.





-----some book---
Inside the Machine: An Illustrated Introduction to Microprocessors and Computer Architecture
Structure and Interpretation of Computer Programs
Design Patterns: Elements of Reusable Object-Oriented Software
Code: The Hidden Language of Computer Hardware and Software
Cracking the Coding Interview: 189 Programming Questions and Solutions
Code Complete: A Practical Handbook of Software Construction
Programming Pearls
The Pragmatic Programmer: Your Journey to Mastery
Code Simplicity: The Fundamentals of Software
Algorithms to Live By: The Computer Science of Human Decisions
Clean Code: A Handbook of Agile Software Craftsmanship
Think Like a Programmer: An Introduction to Creative Problem Solving
Introduction to Algorithms
Peopleware: Productive Projects and Teams
Soft Skills: The software developer’s life manual&nbsp;
Rapid Development: Taming Wild Software Schedules
Coders at Work: Reflections on the Craft of Programming
Don’t Make Me Think, Revisited: A Common Sense Approach to Web Usability
The Passionate Programmer: Creating a Remarkable Career in Software Development
Working Effectively with Legacy Code
The Self-Taught Programmer: The Definitive Guide to Programming Professionally
The Mythical Man-Month: Essays on Software Engineering
Refactoring: Improving the Design of Existing Code
HTML and CSS: Design and Build Websites
Learning Web Design: A Beginner’s Guide to HTML, CSS, JavaScript, and Web Graphics
Eloquent JavaScript: A Modern Introduction to Programming
You Don’t Know JS Yet: Get Started
Effective Java
Head First Java
Java Concurrency in Practice
Modern PHP
Head First PHP &amp; MySQL: A Brain-Friendly Guide
Eloquent Ruby
The Well-Grounded Rubyist
Python Crash Course: A Hands-On, Project-Based Introduction to Programming
Head First Python: A Brain-Friendly Guide
Learn Python 3 the Hard Way: A Very Simple Introduction to the Terrifyingly Beautiful World of Computers and Code
C# in Depth
C# 7.0 in a Nutshell: The Definitive Reference
C Programming Language
Practical C Programming: Why Does 2+2 = 5986?
Objective-C Programming: The Big Nerd Ranch Guide
Effective Objective-C 2.0: 52 Specific Ways to Improve Your IOS and OS X Programs
C++ Primer
Programming: Principles and Practice Using C++
Learning R: A Step-by-Step Function Guide to Data Analysis
R Cookbook: Proven Recipes for Data Analysis, Statistics, and Graphics
The Art of R Programming: A Tour of Statistical Software Design
SQL in 10 Minutes, Sams Teach Yourself
SQL Queries for Mere Mortals: A Hands-On Guide to Data Manipulation in SQL
Android Application Development All-in-One For Dummies
Head First Android Development: A Brain-Friendly Guide
iOS Programming: The Big Nerd Ranch Guide
Swift Programming: The Big Nerd Ranch Guide


--------


被识别叫作语言


A language is called a regular language if some finite automaton recognizes it.


regular operations union, concatenation, and star


nondeterministic finite automaton

EQUIVALENCE OF NFAS AND DFAS
1. 因为NFA会出现一个输入产生两个， 三个， 或多个状态的现象。 
2. 对状态做对自身的笛卡尔积，直到包含了所有状态，  然后重新绘制。 



 language is regular if and only if some nondeterministic finite automaton recognizes it


theorem 1:
 the class of regular languages is closed under the union operation.
构造一个NFA， 空指向两个子NFA。 证毕。

theorem 2:
The class of regular languages is closed under the concatenation operation.
同上， 构造NFA。 一个NFA 空连接另一个  NFA。


the class of regular languages is closed under the star operation.

在accept 状态用空连接 start 状态。 



